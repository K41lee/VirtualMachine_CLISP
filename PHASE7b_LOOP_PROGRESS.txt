================================================================================
                        PHASE 7b - LOOP : RAPPORT DE PROGRESSION
================================================================================

Date: Session actuelle
Statut: ‚ö† EN COURS - 3/5 tests r√©ussis, 2 probl√®mes identifi√©s

================================================================================
1. IMPL√âMENTATION EFFECTU√âE
================================================================================

‚úì Parser LOOP
-------------
- Syntaxe: (loop while condition do body)
- Validation pr√©sence 'while' et 'do'
- Parse correcte des sous-expressions

‚úì compile-loop-while
--------------------
- G√©n√©ration labels LOOP_START et LOOP_END
- Compilation condition
- Branchement conditionnel (BEQ)
- Compilation corps boucle
- Saut inconditionnel retour (J)

‚úì Parser SETQ
-------------
- Syntaxe: (setq var value)
- Support modification variables

‚úì compile-setq
--------------
- Compilation valeur
- Assignation registre ou pile
- Support variables LET

‚úì compile-comparison - CORRECTION S2/S3
----------------------------------------
AVANT (probl√©matique):
  - Utilisait directement $T0/$T1
  - √âcrasait variables LET

APR√àS (corrig√©e):
  - arg1 sauvegard√© sur pile
  - arg2 stock√© dans $S3
  - arg1 restaur√© dans $S2
  - Comparaison SLT $S2 $S3 ‚Üí $V0
  - Plus de conflit avec variables dans $T0/$T1

Registres disponibles VM:
  - Temporaires: T0-T3 (4 seulement)
  - Saved: S0-S3 (4 registres)
  - Arguments: A0-A3
  - Retour: V0

================================================================================
2. R√âSULTATS TESTS
================================================================================

TEST 1: LOOP simple compteur ‚úì R√âUSSI
--------------------------------------
Expression: (let ((x 0))
              (loop while (< x 5) do (setq x (+ x 1)))
              x)
Attendu: 5
Obtenu: 5
Statut: ‚úì PARFAIT

Code ASM g√©n√©r√© (extrait):
  LI 0 $V0              ; x = 0
  MOVE $V0 $T0          ; x ‚Üí $T0
  LABEL LOOP_START_0
  MOVE $T0 $V0          ; Charger x
  ADDI $SP -4 $SP       ; Pile pour arg1
  SW $V0 $SP 0
  LI 5 $V0              ; Constante 5
  MOVE $V0 $S3          ; arg2 ‚Üí $S3 ‚úì
  LW $SP 0 $S2          ; arg1 ‚Üí $S2 ‚úì
  ADDI $SP 4 $SP
  SLT $S2 $S3 $V0       ; x < 5 ‚úì
  ...

Analyse: Une seule variable (x), allocation $T0 OK. Comparaison utilise
correctement $S2/$S3 sans √©craser $T0.


TEST 2: LOOP accumulation ‚úì R√âUSSI
-----------------------------------
Expression: (let ((i 1) (sum 0))
              (loop while (< i 6) do
                (setq sum (+ sum i))
                (setq i (+ i 1)))
              sum)
Attendu: 1+2+3+4+5 = 15
Obtenu: 15
Statut: ‚úì PARFAIT

Analyse: Deux variables (i‚Üí$T0, sum‚Üí$T1). Comparaison utilise $S2/$S3,
n'√©crase plus les variables. Accumulation correcte.


TEST 3: LOOP condition multiple ‚úì R√âUSSI
-----------------------------------------
Expression: (let ((x 0) (y 0))
              (loop while (< x 10) do
                (setq y (+ y x))
                (setq x (+ x 2)))
              y)
Attendu: 0+2+4+6+8 = 20
Obtenu: 20
Statut: ‚úì PARFAIT

Analyse: Variables x‚Üí$T0, y‚Üí$T1. Pas de conflit registres.
Incr√©mentation par 2 fonctionne.


TEST 4: LOOP imbriqu√© ‚úó √âCHEC - BOUCLE INFINIE
-----------------------------------------------
Expression: (let ((i 0) (j 0) (total 0))
              (loop while (< i 3) do
                (setq j 0)
                (loop while (< j 3) do
                  (setq total (+ total 1))
                  (setq j (+ j 1)))
                (setq i (+ i 1)))
              total)
Attendu: 3√ó3 = 9
Obtenu: 1 (apr√®s timeout 1000000 instructions)
Statut: ‚úó BOUCLE INFINIE

Code ASM probl√©matique (extrait boucle interne):
  ...
  (MOVE $T2 $V0)              ; Charger total
  (ADDI $SP -4 $SP)           ; Pile pour (+ total 1)
  (SW $V0 $SP 0)
  (LI 1 $V0)
  (MOVE $V0 $T1)              ; ‚Üê √âCRASE j ! (j √©tait dans $T1)
  (LW $SP 0 $T0)              ; ‚Üê √âCRASE i ! (i √©tait dans $T0)
  (ADDI $SP 4 $SP)
  (ADD $T0 $T1 $V0)
  (MOVE $V0 $T2)              ; total ‚Üê total+1 OK
  (MOVE $T1 $V0)              ; Charger j (mais j √©cras√©!)
  ...

DIAGNOSTIC:
-----------
Variables allou√©es: i‚Üí$T0, j‚Üí$T1, total‚Üí$T2
Mais compile-arithmetic utilise aussi $T0, $T1 pour calculs temporaires !

Dans (+ total 1):
  - total ‚Üí pile (via $V0)
  - 1 ‚Üí $T1 (√âCRASE j!)
  - Restaure total dans $T0 (√âCRASE i!)
  - ADD $T0 $T1 ‚Üí r√©sultat

PROBL√àME: compile-arithmetic ne tient pas compte des variables d√©j√†
allou√©es dans les registres T0-T2. Il les utilise aveugl√©ment comme
temporaires.

SOLUTION N√âCESSAIRE:
- Utiliser pile compl√®te pour calculs arithm√©tiques
- OU utiliser registres S0, S1 pour temporaires arithm√©tiques
- OU analyse liveness registres avant allocation


TEST 5: LOOP avec IF ‚úó √âCHEC - ERREUR LABEL
--------------------------------------------
Expression: (let ((i 0) (even 0) (odd 0))
              (loop while (< i 10) do
                (if (= (mod i 2) 0)
                  (setq even (+ even 1))
                  (setq odd (+ odd 1)))
                (setq i (+ i 1)))
              even)
Attendu: 5
Obtenu: ERREUR
Statut: ‚úó ERREUR RUNTIME

Erreur: >=: EQUAL_4 is not a real number

Code g√©n√©r√© (extrait):
  ...
  (SUB $S2 $S3 $T2)
  (BEQ $T2 $ZERO EQUAL_4)     ; ‚Üê Label EQUAL_4
  (LI 0 $V0)
  (J END_EQ_5)
  (LABEL EQUAL_6)             ; ‚Üê Mais label g√©n√©r√© est EQUAL_6 !
  (LI 1 $V0)
  (LABEL END_EQ_7)
  ...

DIAGNOSTIC:
-----------
Incoh√©rence g√©n√©ration labels dans compile-comparison pour op√©rateur =.
Code g√©n√®re BEQ vers EQUAL_4 mais d√©finit LABEL EQUAL_6.

gen-label() incr√©mente compteur √† chaque appel:
  - BEQ g√©n√®re EQUAL_4 (compteur = 4)
  - LABEL g√©n√®re EQUAL_6 (compteur = 6)

PROBL√àME: Entre BEQ et LABEL, d'autres labels sont g√©n√©r√©s (END_EQ_5),
causant d√©synchronisation.

SOLUTION N√âCESSAIRE:
- Pr√©-g√©n√©rer tous les labels n√©cessaires AVANT de construire le code
- OU modifier gen-label pour ne pas incr√©menter si label d√©j√† g√©n√©r√©


================================================================================
3. PROBL√àMES IDENTIFI√âS
================================================================================

PROBL√àME A: Conflit registres compile-arithmetic (TEST 4)
----------------------------------------------------------
S√©v√©rit√©: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ BLOQUANT pour boucles imbriqu√©es
Impact: Boucles infinies, corruption variables

Description:
  compile-arithmetic utilise directement $T0, $T1 comme registres
  temporaires, sans v√©rifier si des variables y sont stock√©es.

Affect√©:
  - Boucles imbriqu√©es avec 3+ variables
  - Expressions arithm√©tiques complexes dans corps boucle

Solution court terme:
  Modifier compile-arithmetic pour utiliser pile + S0/S1:
  ```lisp
  (defun compile-arithmetic (op args env)
    (let ((code '()))
      ;; arg1 sur pile
      (setf code (append code (compile-expr arg1 env)))
      (setf code (append code
                        (list (list :ADDI *reg-sp* -4 *reg-sp*)
                              (list :SW *reg-v0* *reg-sp* 0))))
      ;; arg2
      (setf code (append code (compile-expr arg2 env)))
      (setf code (append code (list (list :MOVE *reg-v0* *reg-s1*))))
      ;; Restaurer arg1
      (setf code (append code
                        (list (list :LW *reg-sp* 0 *reg-s0*)
                              (list :ADDI *reg-sp* 4 *reg-sp*))))
      ;; Op√©ration $S0 op $S1 ‚Üí $V0
      (case op
        (+ (list (list :ADD *reg-s0* *reg-s1* *reg-v0*)))
        (- (list (list :SUB *reg-s0* *reg-s1* *reg-v0*)))
        ...)))
  ```

Solution long terme:
  - Analyse liveness registres
  - Allocation intelligente variables (utiliser S0-S3 en priorit√©)
  - Descripteur registres global


PROBL√àME B: Incoh√©rence labels compile-comparison = (TEST 5)
-------------------------------------------------------------
S√©v√©rit√©: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ BLOQUANT pour op√©rateur =
Impact: Erreur runtime, code incorrect

Description:
  Dans compile-comparison pour =, le code BEQ r√©f√©rence un label avec
  compteur N, mais le LABEL est g√©n√©r√© avec compteur N+2.

Cause:
  gen-label incr√©mente compteur √† chaque appel. Entre BEQ et LABEL,
  d'autres gen-label sont appel√©s (END_EQ).

Solution:
  Pr√©-g√©n√©rer labels au d√©but de compile-comparison:
  ```lisp
  (defun compile-comparison (op args env)
    ...
    (case op
      (= (let ((label-equal (gen-label env "EQUAL"))
               (label-end-eq (gen-label env "END_EQ")))
           (list (list :SUB *reg-s2* *reg-s3* *reg-t2*)
                 (list :BEQ *reg-t2* *reg-zero* label-equal)
                 (list :LI 0 *reg-v0*)
                 (list :J label-end-eq)
                 (list :LABEL label-equal)
                 (list :LI 1 *reg-v0*)
                 (list :LABEL label-end-eq))))
      ...))
  ```


================================================================================
4. M√âTRIQUES
================================================================================

Tests: 3/5 r√©ussis (60%)
Temps d√©veloppement: ~3h
Lignes code ajout√©es: ~120 lignes
  - compile-loop-while: 30 lignes
  - compile-setq: 30 lignes
  - compile-comparison (correction): 40 lignes
  - Parser: 20 lignes

Performance (tests r√©ussis):
  - Test 1: < 0.1s
  - Test 2: < 0.1s
  - Test 3: < 0.1s

Code g√©n√©r√© (test 2):
  - 44 instructions ASM
  - 6 it√©rations boucle
  - Pas d'optimisation

Registres utilis√©s:
  - Variables: T0, T1, T2
  - Comparaisons: S2, S3
  - Temporaires arith: T0-T3 (PROBL√àME!)


================================================================================
5. PLAN CORRECTION
================================================================================

PRIORIT√â 1: Corriger compile-arithmetic (30 min)
-------------------------------------------------
Modifier pour utiliser pile + S0/S1 au lieu de T0/T1.
Permettra test 4 de passer.

PRIORIT√â 2: Corriger labels compile-comparison = (15 min)
----------------------------------------------------------
Pr√©-g√©n√©rer labels au d√©but des cases =, /=.
Permettra test 5 de passer.

PRIORIT√â 3: Tests validation (15 min)
--------------------------------------
Relancer tous tests LOOP.
Objectif: 5/5 tests r√©ussis.

PRIORIT√â 4: Documentation (30 min)
-----------------------------------
Cr√©er PHASE7b_LOOP_COMPLETE.txt
Mettre √† jour todo list
Pr√©parer Phase 8 (LABELS)


================================================================================
6. CONCLUSION INTERM√âDIAIRE
================================================================================

‚úì ACQUIS Phase 7b:
------------------
- Structure LOOP fonctionnelle (parser, compile, labels)
- SETQ op√©rationnel
- Correction majeure compile-comparison (S2/S3)
- 3 tests sur 5 passent (boucles simples OK)

‚ö† RESTE √Ä FAIRE:
----------------
- Corriger compile-arithmetic (conflit registres)
- Corriger g√©n√©ration labels op√©rateur =
- Valider 2 tests restants

üéØ OBJECTIF:
------------
Phase 7b compl√®te d'ici 1-2h suppl√©mentaires.
Tests 5/5 r√©ussis.
Documentation finalis√©e.
Pr√™t pour Phase 8 (LABELS).

================================================================================
