â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PLAN SIMPLIFIÃ‰ - PHASE 11 VMâ‚                            â•‘
â•‘                     Compiler VM en MIPS                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Date: 27 novembre 2025 - Mise Ã  jour aprÃ¨s implÃ©mentation ARRAYS
DurÃ©e estimÃ©e: 25-32 heures (rÃ©duit grÃ¢ce aux extensions dÃ©jÃ  implÃ©mentÃ©es)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCHITECTURE CLARIFIÃ‰E
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚  VMâ‚€ (Native)  =  src/vm.lisp exÃ©cutÃ©e en LISP natif                 â”‚
â”‚  VMâ‚ (CompilÃ©e) =  src/vm.lisp compilÃ©e en MIPS, chargÃ©e dans VMâ‚€    â”‚
â”‚                                                                        â”‚
â”‚  C'est la MÃŠME VM, juste deux versions :                             â”‚
â”‚    - VMâ‚€ : InterprÃ©teur LISP natif                                   â”‚
â”‚    - VMâ‚ : Code MIPS dans mÃ©moire de VMâ‚€                             â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Flux d'exÃ©cution :
  Programme LISP â†’ Compilateur â†’ Code MIPS (code_prog)
                                      â†“
                              VMâ‚ (en MIPS) charge code_prog
                                      â†“
                              VMâ‚€ (native) exÃ©cute VMâ‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FICHIERS DU PROJET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FICHIERS PRINCIPAUX (Ã  utiliser pour Phase 11)
â”œâ”€â”€ src/vm.lisp                 â† BASE POUR VMâ‚ (686 lignes)
â”œâ”€â”€ src/compiler.lisp           â† Compilateur Ã  Ã©tendre
â”œâ”€â”€ src/loader.lisp             â† Loader pour charger code
â”œâ”€â”€ src/asm-ops.lisp            â† Opcodes et constantes
â””â”€â”€ src/utils.lisp              â† Utilitaires

FICHIERS BOOTSTRAP (Phase 10 - rÃ©fÃ©rence historique uniquement)
â”œâ”€â”€ src/bootstrap/vm-bootstrap.lisp          (version sans debug)
â”œâ”€â”€ src/bootstrap/compiler-bootstrap.lisp    (gÃ©nÃ©rÃ© = identique)
â”œâ”€â”€ src/bootstrap/loader-bootstrap.lisp      (version sans debug)
â””â”€â”€ src/bootstrap/primitives.lisp            (fonctions LISP pures)

Note: Les fichiers bootstrap ne sont PAS nÃ©cessaires pour Phase 11
      Ils sont gardÃ©s pour historique Phase 10 uniquement

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 1 : ANALYSE src/vm.lisp âœ… TERMINÃ‰ (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 1.1 Lister toutes les fonctions de vm.lisp
    AnalysÃ© : 687 lignes
    RÃ©sultat : 35 fonctions identifiÃ©es
    Fichier : docs/phases/phase11/ANALYSE_VM_CONSTRUCTS.txt

[âœ…] 1.2 Identifier les constructions LISP utilisÃ©es
    RÃ©sultats dÃ©taillÃ©s dans : docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
    TrouvÃ© :
      - DEFSTRUCT (vm) : 1 occurrence â†’ Variables globales
      - HASH-TABLE : 4 usages â†’ Arrays avec indices
      - DOLIST : 2 occurrences â†’ WHILE indexÃ©
      - LOOP : 3 occurrences â†’ WHILE
      - FORMAT : ~40 occurrences â†’ Suppression
      - CASE : OK (dÃ©jÃ  supportÃ©)

[âœ…] 1.3 CrÃ©er une liste de dÃ©pendances
    Fichiers crÃ©Ã©s :
      - docs/phases/phase11/ANALYSE_VM_CONSTRUCTS.txt
      - docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
      - docs/phases/phase11/PLAN_SIMPLIFICATION_VM.txt
    
    Extensions critiques identifiÃ©es :
      âœ… WHILE loops (implÃ©mentÃ© - 10/10 tests)
      âœ… PROGN sequences (implÃ©mentÃ©)
      âœ… ARRAYS (implÃ©mentÃ© - 12/12 tests)
      â¸ï¸ DOLIST (ne sera PAS implÃ©mentÃ© - voir stratÃ©gie alternative)
      âœ… CASE (dÃ©jÃ  supportÃ© dans compilateur)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 2 : BOUCLES âœ… TERMINÃ‰ (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 2.1 ImplÃ©menter WHILE dans le compilateur
    Fichier : src/compiler.lisp (fonction compile-while, ligne ~1220)
    Documentation : src/compiler-extensions/compile-while.lisp
    
    Syntaxe implÃ©mentÃ©e :
      (while condition body...)
    
    GÃ©nÃ©ration MIPS :
      WHILE_START:
        ; Ã©valuer condition â†’ $V0
        BEQ $V0 $ZERO WHILE_END
        ; exÃ©cuter body (avec PROGN si multiple)
        J WHILE_START
      WHILE_END:
        MOVE $ZERO $V0  ; retourne NIL
    
    Tests : tests/unit/test-while.lisp
      [âœ…] Boucle simple compteur
      [âœ…] Accumulation valeurs
      [âœ…] Condition fausse initialement
      [âœ…] Condition nil
      [âœ…] Multi-instructions dans body
      [âœ…] Boucles imbriquÃ©es
      [âœ…] Calcul factorielle
      [âœ…] Conditions AND
      [âœ…] Double condition
      [âœ…] Retourne nil
    
    RÃ©sultat : 10/10 tests passent âœ…

[âœ…] 2.2 IntÃ©grer WHILE dans src/compiler.lisp
    AjoutÃ© clause (:while ...) dans compile-expr (ligne ~1916)
    Parser WHILE ajoutÃ© (ligne ~295)

[âœ…] 2.3 BONUS : ImplÃ©menter PROGN
    NÃ©cessaire pour body WHILE avec plusieurs expressions
    Fonction compile-progn ajoutÃ©e (ligne ~1283)
    Parser PROGN ajoutÃ© (ligne ~303)
    Tests : IntÃ©grÃ©s dans test-while.lisp

Note: LOOP de Common Lisp sera transformÃ© en WHILE dans vm-compilable.lisp

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 3 : ARRAYS âœ… TERMINÃ‰ (2h30)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 3.1 ImplÃ©menter ARRAYS
    Fichiers :
      - src/compiler.lisp : Fonctions compile-make-array (ligne ~1307),
                           compile-aref (ligne ~1405),
                           compile-setf-aref (ligne ~1426)
      - Documentation : src/compiler-extensions/compile-arrays.lisp (450 lignes)
    
    Fonctions implÃ©mentÃ©es :
      (make-array size [:initial-element value]) â†’ Allocation tas avec $gp
      (aref array index)                         â†’ Lecture Ã©lÃ©ment
      (setf (aref array index) value)           â†’ Ã‰criture Ã©lÃ©ment
    
    ImplÃ©mentation MIPS :
      make-array :
        - Structure : [MAGIC(0xA88A)][SIZE][elem0][elem1]...[elemN]
        - Allouer (2 + size) mots avec $gp (Global Pointer)
        - Initialisation optionnelle avec boucle WHILE
        - Retourne adresse de base dans $V0
      
      aref :
        - Calculer offset = index + 2 (pour header)
        - Adresse effective = base + offset
        - LW value de l'adresse (offset 0)
      
      setf aref :
        - MÃªme calcul d'adresse
        - SW value Ã  l'adresse
        - Retourne value (comportement SETF)

    Tests : tests/unit/test-arrays.lisp (155 lignes)
      [âœ…] CrÃ©er array de taille 5
      [âœ…] Lire Ã©lÃ©ment par dÃ©faut (sans init)
      [âœ…] CrÃ©er avec :initial-element 42
      [âœ…] Lire diffÃ©rents indices (init 99)
      [âœ…] Ã‰crire avec setf aref
      [âœ…] Ã‰crire index 3, lire index 3
      [âœ…] Ã‰lÃ©ments indÃ©pendants
      [âœ…] Boucle WHILE remplissage array
      [âœ…] Accumuler valeurs array avec WHILE
      [âœ…] Array avec calculs (carrÃ©s)
      [âœ…] CrÃ©er plusieurs arrays indÃ©pendants
      [âœ…] SETF AREF retourne la valeur assignÃ©e
    
    RÃ©sultat : 12/12 tests passent âœ…

[âœ…] 3.2 IntÃ©grer dans src/compiler.lisp
    - Parser make-array ajoutÃ© (ligne ~307)
    - Parser aref ajoutÃ© (ligne ~314)
    - Parser setf aref ajoutÃ© (ligne ~330, dÃ©tection dans case setq)
    - Clauses compile-expr : :make-array (ligne ~1930), :aref (ligne ~1933),
                            :setf-aref (ligne ~1942)
    - Registres t4-t7 ajoutÃ©s (ligne 15-18)
    - Support $gp dans get-reg (src/asm-ops.lisp, ligne 139)

    Code ajoutÃ© : +234 lignes dans src/compiler.lisp
                 +1 ligne dans src/asm-ops.lisp

Documentation complÃ¨te : docs/phases/phase11/IMPLEMENTATION_ARRAYS.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 4 : CASE âœ… DÃ‰JÃ€ SUPPORTÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 4.1 CASE dÃ©jÃ  implÃ©mentÃ©
    Le compilateur supporte dÃ©jÃ  CASE depuis les phases prÃ©cÃ©dentes
    Fichier : src/compiler.lisp
    
    Syntaxe supportÃ©e :
      (case expr
        (val1 body1)
        (val2 body2)
        (t default))
    
    ImplÃ©mentation :
      - Parser dans parse-lisp-expr
      - Fonction compile-case existante
      - GÃ©nÃ¨re des labels et branches BEQ pour chaque cas
      - Support du cas default avec (t ...)

[âœ…] 4.2 DÃ©jÃ  intÃ©grÃ© dans src/compiler.lisp
    Clause (:case ...) prÃ©sente dans compile-expr

Note : CASE est utilisÃ© massivement dans execute-instruction de vm.lisp
       pour dispatcher les 40+ opcodes. Pas de modifications nÃ©cessaires.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 5 : SIMPLIFIER DEFSTRUCT ET HASH-TABLES âœ… TERMINÃ‰ (2h30)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 5.0 Analyse et planification
    Fichiers crÃ©Ã©s :
      - docs/phases/phase11/PLAN_SIMPLIFICATION_VM.txt
      - docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
      - src/compiler-extensions/compile-dolist.lisp (stratÃ©gie alternative)
    
    Transformations identifiÃ©es :
      â€¢ DEFSTRUCT â†’ Variables globales (1 occurrence)
      â€¢ HASH-TABLE â†’ Arrays avec indices (4 usages)
      â€¢ DOLIST â†’ WHILE indexÃ© (2 occurrences)
      â€¢ LOOP â†’ WHILE (3 occurrences)
      â€¢ FORMAT â†’ Suppression (~40 occurrences)
      â€¢ Keywords â†’ Constantes numÃ©riques
    
    Estimation initiale : 5h45
    Temps rÃ©el : 2h30

[âœ…] 5.1 CrÃ©er src/vm-compilable.lisp (âœ… FAIT)
    Copie de src/vm.lisp (687 lignes) avec simplifications :
    
    âœ… Ã‰tape 1 : DÃ©finir constantes et variables globales
      - Constantes d'Ã©tat : +state-ready+ (0), +state-running+ (1),
                           +state-halted+ (2), +state-error+ (3)
      - Variables globales : *vm-memory*, *vm-registers*, *vm-state*,
                            *vm-instruction-count*, *vm-verbose*
    
    âœ… Ã‰tape 2 : Supprimer DEFSTRUCT et accesseurs
      - (defstruct vm) supprimÃ©
      - ParamÃ¨tre (vm) supprimÃ© de TOUTES les fonctions
      - ~150 rÃ©fÃ©rences transformÃ©es
    
    âœ… Ã‰tape 3 : Remplacer HASH-TABLE par ARRAY
      - Fonction reg-index crÃ©Ã©e (42 registres: 0-31 gÃ©nÃ©raux, 32-41 spÃ©ciaux)
      - Tous les gethash remplacÃ©s par aref + reg-index
      - Tous les setf/gethash remplacÃ©s par setq/aref
    
    âœ… Ã‰tape 4 : Transformer DOLIST (2 occurrences)
      - init-registers: WHILE avec compteur 0-41
      - dump-registers: fonction dÃ©sactivÃ©e (retourne T)
    
    âœ… Ã‰tape 5 : Transformer LOOP (3 occurrences)
      - run-vm: LOOP â†’ WHILE avec condition sur *vm-state*
      - dump-memory/dump-stack: fonctions dÃ©sactivÃ©es
    
    âœ… Ã‰tape 6 : Supprimer FORMAT (~40 occurrences)
      - Tous les (format t ...) supprimÃ©s
      - Blocs (when (vm-verbose vm) ...) supprimÃ©s
      - Script Python pour suppression automatique
    
    âœ… Ã‰tape 7 : Remplacer keywords par constantes
      - Tous les :ready/:running/:halted/:error remplacÃ©s
      - Comparaisons (eq state :running) â†’ (= state +state-running+)

[âœ…] 5.2 Remplacer ERROR et HANDLER-CASE
    - HANDLER-CASE supprimÃ© de run-vm
    - Gestion d'erreur simplifiÃ©e avec changement d'Ã©tat
    - (error "msg") remplacÃ© par (setq *vm-state* +state-error+)

[âœ…] 5.3 Tester vm-compilable.lisp en LISP natif
    âœ“ Chargement : (load "src/vm-compilable.lisp") â†’ SUCCÃˆS
    âœ“ Pas d'erreurs de syntaxe
    âœ“ ~690 lignes (vs 687 dans vm.lisp)
    
    Note: Tests complets impossibles sans WHILE (extension compilateur)
    Fichier : docs/phases/phase11/PHASE5_SIMPLIFICATION_COMPLETE.txt

[âœ…] 5.4 VÃ©rifications finales
    âœ… Pas de DEFSTRUCT
    âœ… Pas de HASH-TABLE / GETHASH
    âœ… Pas de DOLIST
    âœ… Pas de LOOP
    âœ… Pas de FORMAT
    âœ… Pas de keywords d'Ã©tat
    âœ… Pas de SETF (remplacÃ© par SETQ)
    âœ… Pas de INCF/DECF
    âœ… Pas de HANDLER-CASE
    
    Constructions utilisÃ©es (toutes supportÃ©es) :
      âœ“ DEFUN, DEFVAR, DEFCONSTANT, LET, PROGN
      âœ“ WHILE, CASE, COND, WHEN, SETQ, AREF, MAKE-ARRAY
      âœ“ ArithmÃ©tique, comparaisons, logique, RETURN-FROM

RÃ©sultat Phase 5 : âœ… SUCCÃˆS
  Fichier : src/vm-compilable.lisp (~690 lignes)
  Ã‰tat : PrÃªt pour compilation en MIPS
  Documentation : docs/phases/phase11/PHASE5_SIMPLIFICATION_COMPLETE.txt

Tests de base (Note: nÃ©cessitent chargement du compilateur pour WHILE) :
      [ ] (+ 2 3) â†’ 5
      [ ] (let ((x 10)) (* x 2)) â†’ 20
      [ ] Boucle simple

Note : Les opcodes restent des keywords (:ADD, :SUB, etc.) car dÃ©jÃ 
       supportÃ©s par CASE. Pas besoin de les encoder en entiers.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 6 : COMPILATION VM - OPTION A (20-35 jours) ğŸ”„ STRATÃ‰GIE RÃ‰VISÃ‰E
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ DÃ‰CISION STRATÃ‰GIQUE - 27 NOVEMBRE 2025 (20:30) âš ï¸

AprÃ¨s analyse dÃ©taillÃ©e (docs/phases/phase11/ANALYSE_COMPILATION_VM.md),
la compilation complÃ¨te de la VM nÃ©cessite l'implÃ©mentation de constructions
Lisp critiques manquantes. Nous suivons maintenant l'OPTION A : Compilation
ComplÃ¨te avec implÃ©mentation incrÃ©mentale des constructions.

RÃ©fÃ©rence : docs/phases/phase11/ANALYSE_COMPILATION_VM.md
  - Analyse complÃ¨te des obstacles
  - 3 options Ã©valuÃ©es (A: complÃ¨te, B: refactorisation, C: micro-VM)
  - Option A choisie pour dÃ©veloppement long-terme

Constructions critiques manquantes :
  âŒ DEFSTRUCT (â­â­â­â­â­, 5-7j) - Structure VM
  âŒ HASH-TABLES (â­â­â­â­â­, 3-5j) - Registres (ou tableau fixe: 1j)
  âŒ DOLIST/LOOP (â­â­â­â­â­, 2-3j) - ItÃ©ration
  âŒ WHEN/UNLESS (â­â­â­â­, 4-6h) - Conditions simples
  âŒ LIST OPS (â­â­â­â­, 2-4j) - Cons, car, cdr, etc.

Effort total : 20-35 jours
Couverture : 32% â†’ 100% (8/25 â†’ 25/25 constructions)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HISTORIQUE - SESSIONS PRÃ‰CÃ‰DENTES (Progression Initiale AbandonnÃ©e)

SESSION 1-3 : EXTENSIONS COMPILATEUR (5.5h) âœ…
  [âœ…] DEFVAR/DEFCONSTANT support (2h)
  [âœ…] ERROR/FORMAT suppression (1.5h)
  [âœ…] IntrinsÃ¨ques GET-REGISTER/SET-REGISTER (2h)
  
  RÃ©sultat : 62% (16/26 DEFUN), 1130 lignes MIPS gÃ©nÃ©rÃ©es

SESSION 4 : BUG FIX CRITIQUE - DOTTED PAIRS (2h) âœ…
  [âœ…] 6.1 Identification du bug
    SymptÃ´me : "SECOND: 0 is not a list" dans DEFUN+LET
    Cause : Variables pile stockÃ©es comme dotted pairs (:stack . offset)
    Impact : Bloquait ALLOC-MEMORY, PUSH-STACK, POP-STACK, PEEK-STACK
  
  [âœ…] 6.2 Debug progressif
    - Isolation du bug : LET seul marche, DEFUN seul marche, combinaison Ã©choue
    - Trace complÃ¨te avec format debug
    - DÃ©couverte : var-info = ((STACK . 0) . 0)
    - location = (STACK . 0) â†’ dotted pair
    - (second (STACK . 0)) â†’ (car (cdr (STACK . 0))) â†’ (car 0) â†’ ERROR
  
  [âœ…] 6.3 Solution appliquÃ©e
    Fichier : src/compiler.lisp, fonction compile-variable
    Changements (3 lignes) :
      Ligne 676 : (second location) â†’ (cdr location)  ; Cas :stack
      Ligne 681 : (second location) â†’ (cdr location)  ; Cas :fp
      Ligne 686 : (second location) â†’ (cdr location)  ; Cas :closure
    
    Explication : Les locations sont crÃ©Ã©es avec (cons :tag value),
                 produisant des dotted pairs, pas des listes.
                 Il faut (cdr ...) pour extraire la valeur, pas (second ...).
  
  [âœ…] 6.4 Tests de validation
    âœ“ test-let-simple.lisp : LET basique (3 instructions)
    âœ“ test-let-get-register.lisp : LET + intrinsÃ¨que (3 instructions)
    âœ“ test-defun-isolation.lisp : 8/8 tests passent
      - DEFUN vide : 9 instructions
      - DEFUN+LET : 13 instructions â† MAINTENANT FONCTIONNE
      - DEFUN+LET+GET-REGISTER : 13 instructions
      - DEFUN+multiple expressions : 14 instructions
      - DEFUN+WHEN : 22 instructions
      - DEFUN+LET+WHEN : 26 instructions
      - DEFUN+LET+WHEN+SET-REGISTER : 36 instructions
      - ALLOC-MEMORY-like : 44 instructions â† DÃ‰BLOQUÃ‰
    
    âœ“ rapport-session4.lisp : Tous les tests passent
  
  [âœ…] 6.5 Impact et dÃ©blocage
    Fonctions dÃ©bloquÃ©es :
      âœ“ ALLOC-MEMORY (utilise LET avec GET-REGISTER)
      âœ“ PUSH-STACK (utilise LET)
      âœ“ POP-STACK (utilise LET*)
      âœ“ PEEK-STACK (utilise LET)
      + 4-5 autres fonctions utilisant LET dans DEFUN
    
    Progression attendue : 62% â†’ 77% (estimation +4-5 fonctions)

SESSION 5 : TESTS & ANALYSE (2h) âœ…
  [âœ…] Correction bug DEFUN labels (81% â†’ 100% tests)
  [âœ…] CrÃ©ation benchmarks performance
  [âœ…] RÃ©sultats : VM0 = 500x-2400x plus lent que CLISP
  [âœ…] Analyse obstacles compilation VM â†’ Option A choisie

Note : Ces sessions ont montrÃ© que l'approche initiale (compiler la VM
       directement) nÃ©cessite trop de constructions manquantes. Changement
       de stratÃ©gie vers Option A : implÃ©mentation incrÃ©mentale.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NOUVELLE FEUILLE DE ROUTE - OPTION A COMPLÃˆTE (20-35 jours)

SPRINT 1 : CONSTRUCTIONS SIMPLES (1-2 jours) ğŸ”„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 6.1 ImplÃ©menter WHEN/UNLESS (4-6h)
    PrioritÃ© : â­â­â­â­ Haute  |  ComplexitÃ© : â­â­ Moyenne
    
    Approche : Macro expansion sur IF existant
      (when test body...) â†’ (if test (progn body...) nil)
      (unless test body...) â†’ (if (not test) (progn body...) nil)
    
    NÃ©cessite d'abord : ImplÃ©menter NOT (opÃ©rateur logique)
      (not x) â†’ (if x nil t)
    
    Fichiers :
      - src/compiler.lisp : compile-when, compile-unless, compile-not
      - Tests : tests/unit/test-when-unless.lisp (10 tests)
    
    Tests attendus :
      âœ“ (when t 42) â†’ 42
      âœ“ (when nil 42) â†’ nil
      âœ“ (unless nil 42) â†’ 42
      âœ“ (when (> x 5) (* x 2))
      âœ“ Body multiple expressions
      âœ“ ImbriquÃ©s
    
    Impact : DÃ©bloque ~30% conditions dans vm.lisp
    Estimation : 4-6 heures

[ ] 6.2 ImplÃ©menter INCF/DECF/PUSH/POP (4-6h)
    PrioritÃ© : â­â­â­ Moyenne-Haute  |  ComplexitÃ© : â­â­ Moyenne
    
    Approche : Macros sur SETQ existant
      (incf var delta) â†’ (setq var (+ var delta))
      (incf var) â†’ (setq var (+ var 1))
      (decf var delta) â†’ (setq var (- var delta))
      (push item list) â†’ (setq list (cons item list))
      (pop list) â†’ (let ((x (car list))) (setq list (cdr list)) x)
    
    NÃ©cessite : CAR/CDR/CONS (voir Sprint 2)
    
    Fichiers :
      - src/compiler.lisp : compile-incf, compile-decf, compile-push, compile-pop
      - Tests : tests/unit/test-incf-decf.lisp (8 tests)
    
    Tests attendus :
      âœ“ (let ((x 10)) (incf x) x) â†’ 11
      âœ“ (let ((x 10)) (incf x 5) x) â†’ 15
      âœ“ (let ((x 10)) (decf x 3) x) â†’ 7
      âœ“ (let ((l nil)) (push 1 l) (push 2 l) l) â†’ (2 1)
    
    Impact : DÃ©bloque heap pointer (*heap-pointer*), pile, listes
    Estimation : 4-6 heures

[ ] 6.3 ImplÃ©menter ERROR â†’ PRINT+HALT (2-4h)
    PrioritÃ© : â­â­â­ Moyenne  |  ComplexitÃ© : â­ Faible
    
    Approche : Remplacement simple
      (error "msg") â†’ (progn (halt))
      ou (error "msg ~A" val) â†’ (progn (print val) (halt))
    
    NÃ©cessite : PRINT basique (afficher entier en $V0)
      - Syscall PRINT_INT (si disponible)
      - Ou stocker dans registre dÃ©diÃ© pour debug externe
    
    Fichiers :
      - src/compiler.lisp : compile-error, compile-print (optionnel)
      - Tests : tests/unit/test-error.lisp (5 tests)
    
    Tests attendus :
      âœ“ (error "test") â†’ halt
      âœ“ (when (< x 0) (error "negative")) â†’ halt si x<0
    
    Impact : Gestion erreurs (non-robuste mais fonctionnelle)
    Estimation : 2-4 heures

Total Sprint 1 : 10-16 heures (~1-2 jours)

SPRINT 2 : MANIPULATION DE LISTES (2-4 jours) ğŸ”„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 6.4 ImplÃ©menter LIST OPS basiques (2-4 jours)
    PrioritÃ© : â­â­â­â­ Haute  |  ComplexitÃ© : â­â­â­â­ Ã‰levÃ©e
    
    Fonctions Ã  implÃ©menter :
      â€¢ CONS (allocation cons cell) - CRITIQUE
      â€¢ CAR / FIRST (accÃ¨s head)
      â€¢ CDR / REST (accÃ¨s tail)
      â€¢ NULL (test vide, compare Ã  0)
      â€¢ MEMBER (recherche dans liste) - optionnel
      â€¢ ASSOC (recherche dans alist) - optionnel
    
    ReprÃ©sentation cons cell :
      Structure : [CAR_VALUE][CDR_VALUE] (2 mots)
      NIL : Adresse 0 (convention)
      Allocation : Utiliser $GP (heap pointer) comme pour make-array
    
    ImplÃ©mentation CONS :
      1. Allouer 2 mots avec $GP
      2. Stocker CAR Ã  [addr+0]
      3. Stocker CDR Ã  [addr+1]
      4. Retourner addr dans $V0
    
    ImplÃ©mentation CAR :
      1. LW $V0 0($A0)  ; charger mot 0
    
    ImplÃ©mentation CDR :
      1. LW $V0 4($A0)  ; charger mot 1
    
    ImplÃ©mentation NULL :
      1. SEQ $V0 $A0 $ZERO  ; compare Ã  0
    
    Fichiers :
      - src/compiler.lisp : compile-cons, compile-car, compile-cdr, compile-null
      - Tests : tests/unit/test-list-ops.lisp (20+ tests complets)
    
    Tests attendus :
      âœ“ (cons 1 2) â†’ dotted pair [1|2]
      âœ“ (cons 1 nil) â†’ liste [1]
      âœ“ (cons 1 (cons 2 nil)) â†’ liste [1 2]
      âœ“ (car (cons 1 2)) â†’ 1
      âœ“ (cdr (cons 1 2)) â†’ 2
      âœ“ (null nil) â†’ t
      âœ“ (null (cons 1 2)) â†’ nil
      âœ“ Construction listes longues
      âœ“ Navigation car/cdr imbriquÃ©s
    
    Impact : DÃ©bloque PUSH/POP, DOLIST, navigation environnements
    Estimation : 2-4 jours (complexe car allocation dynamique)

[ ] 6.5 ImplÃ©menter DOLIST (1 jour)
    PrioritÃ© : â­â­â­â­â­ CRITIQUE  |  ComplexitÃ© : â­â­â­ Moyenne-Haute
    
    DÃ©pendances : CAR, CDR, NULL (Sprint 2.4)
    
    Approche : Macro expansion en WHILE
      (dolist (var list) body...)
      â†’
      (let ((temp-list list))
        (while (not (null temp-list))
          (let ((var (car temp-list)))
            body...
            (setq temp-list (cdr temp-list)))))
    
    Fichiers :
      - src/compiler.lisp : compile-dolist (macro expansion complexe)
      - Tests : tests/unit/test-dolist.lisp (12 tests)
    
    Tests attendus :
      âœ“ (let ((sum 0)) (dolist (x '(1 2 3)) (setq sum (+ sum x))) sum) â†’ 6
      âœ“ (let ((acc nil)) (dolist (x '(1 2 3)) (push x acc)) acc) â†’ (3 2 1)
      âœ“ Liste vide
      âœ“ Body multiple expressions
      âœ“ DOLIST imbriquÃ©s
    
    Impact : DÃ©bloque init-registers (boucle sur *register-names*)
    Estimation : 1 jour (8h)

Total Sprint 2 : 3-5 jours

SPRINT 3 : STRUCTURES DE DONNÃ‰ES (3-6 jours) ğŸ”„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 6.6 OPTION RECOMMANDÃ‰E : Registres en Tableau Fixe (1 jour)
    PrioritÃ© : â­â­â­â­â­ CRITIQUE  |  ComplexitÃ© : â­â­ Moyenne
    
    Alternative Ã  HASH-TABLES : Plus simple et rapide
    
    Approche :
      1. DÃ©finir tableau fixe *vm-registers* de 42 Ã©lÃ©ments
      2. Mapping symboleâ†’index hardcodÃ© :
         :$ZERO â†’ 0, :$AT â†’ 1, :$V0 â†’ 2, ..., :$RA â†’ 31
         :$PC â†’ 32, :$SP â†’ 33, :$FP â†’ 34, etc.
      3. Remplacer (gethash :$V0 regs) â†’ (aref regs 2)
      4. Fonction reg-index pour lookup (dÃ©jÃ  fait dans vm-compilable.lisp âœ…)
    
    Fichiers :
      - src/vm-compilable.lisp : DÃ©jÃ  refactorisÃ© âœ…
      - src/compiler.lisp : Support reg-index si nÃ©cessaire
      - Tests : tests/unit/test-register-array.lisp (validation)
    
    Tests attendus :
      âœ“ (get-register :$V0) â†’ accÃ¨s correct
      âœ“ (set-register :$V0 42) â†’ stockage correct
      âœ“ init-registers initialise tous les registres
    
    Impact : DÃ©bloque get-register, set-register, execute-instruction
    Estimation : 1 jour (dÃ©jÃ  fait en Phase 5 âœ…, juste valider)

[ ] 6.7 OPTION ALTERNATIVE : ImplÃ©menter HASH-TABLES (3-5 jours)
    PrioritÃ© : â­â­â­â­â­ CRITIQUE  |  ComplexitÃ© : â­â­â­â­â­ TrÃ¨s Ã‰levÃ©e
    
    âš ï¸ NON RECOMMANDÃ‰ : Trop complexe pour rÃ©sultat identique Ã  6.6
    
    Si implÃ©mentÃ© quand mÃªme :
      - Fonction de hachage pour symboles (hash string â†’ index)
      - Gestion collisions (chaining avec listes, nÃ©cessite CONS/CAR/CDR)
      - Structure : [SIZE][BUCKETS...][...chains...]
      - MAKE-HASH-TABLE, GETHASH, SETF GETHASH, REMHASH
    
    Estimation : 3-5 jours (vs 1 jour pour option 6.6)

[ ] 6.8 ImplÃ©menter DEFSTRUCT SimplifiÃ© (2-3 jours)
    PrioritÃ© : â­â­â­â­â­ CRITIQUE  |  ComplexitÃ© : â­â­â­â­ Ã‰levÃ©e
    
    Note : Peut Ãªtre Ã©vitÃ© si on utilise vm-compilable.lisp (dÃ©jÃ  refactorisÃ© âœ…)
    
    Si implÃ©mentÃ© pour vm.lisp original :
      Approche :
        1. Parser (defstruct name (slot1 val1) ...)
        2. GÃ©nÃ©rer MAKE-NAME : (defun make-name (...) (make-array n))
        3. GÃ©nÃ©rer accesseurs : (defun name-slot1 (obj) (aref obj 0))
        4. GÃ©nÃ©rer setters : (defun set-name-slot1 (obj val) (setq (aref obj 0) val))
      
      ReprÃ©sentation : Array [TYPE_TAG][SLOT0][SLOT1]...[SLOTN]
      
      Fichiers :
        - src/compiler.lisp : compile-defstruct (code generation)
        - Tests : tests/unit/test-defstruct.lisp (15+ tests)
      
      Tests attendus :
        âœ“ (defstruct point (x 0) (y 0))
        âœ“ (make-point) â†’ crÃ©e array
        âœ“ (point-x p) â†’ accÃ¨s correct
        âœ“ (setf (point-x p) 10) â†’ modification
      
      Impact : DÃ©bloque structure VM (mais dÃ©jÃ  contournÃ© âœ…)
      Estimation : 2-3 jours
    
    RECOMMANDATION : SKIP (utiliser vm-compilable.lisp)

Total Sprint 3 : 1-3 jours (si on skip DEFSTRUCT et HASH-TABLES)

SPRINT 4 : LOOP ET FEATURES AVANCÃ‰ES (1-3 jours) ğŸ”„
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 6.9 ImplÃ©menter LOOP basique (1-2 jours)
    PrioritÃ© : â­â­â­â­â­ CRITIQUE  |  ComplexitÃ© : â­â­â­â­ Ã‰levÃ©e
    
    DÃ©pendances : RETURN-FROM (dÃ©jÃ  implÃ©mentÃ© âœ…)
    
    Approche : Subset minimal
      Forme 1 : (loop (when test (return val)) ...)
      Forme 2 : (loop ... (unless test (return val)))
      Transformation : WHILE infini + RETURN-FROM
    
    Exemple :
      (loop
        (when done (return result))
        ... body ...)
      â†’
      (let ((done nil) (result nil))
        (while t
          (when done (return-from loop-block result))
          ... body ...))
    
    Fichiers :
      - src/compiler.lisp : compile-loop (macro complexe)
      - Tests : tests/unit/test-loop.lisp (10 tests)
    
    Tests attendus :
      âœ“ (let ((i 0)) (loop (when (> i 5) (return i)) (incf i))) â†’ 6
      âœ“ Boucle infinie avec condition sortie
      âœ“ LOOP avec RETURN multiple
    
    Impact : DÃ©bloque run-vm (boucle principale), recherches environnement
    Estimation : 1-2 jours
    
    ALTERNATIVE : DÃ©jÃ  transformÃ© en WHILE dans vm-compilable.lisp âœ…
    RECOMMANDATION : SKIP (dÃ©jÃ  fait manuellement)

[ ] 6.10 ImplÃ©menter FORMAT basique (1-2 jours) - OPTIONNEL
    PrioritÃ© : â­â­â­ Moyenne  |  ComplexitÃ© : â­â­â­ Moyenne-Haute
    
    âš ï¸ NON CRITIQUE : Debug seulement
    
    Subset minimal :
      ~A : any (afficher entier)
      ~% : newline
      ~D : decimal (= ~A)
    
    Approche :
      1. Parser format string
      2. Pour chaque directive, gÃ©nÃ©rer code PRINT
      3. Utiliser syscall PRINT_INT + PRINT_CHAR
    
    Fichiers :
      - src/compiler.lisp : compile-format
      - Tests : tests/unit/test-format.lisp
    
    ALTERNATIVE : DÃ©jÃ  supprimÃ© dans vm-compilable.lisp âœ…
    RECOMMANDATION : SKIP

[ ] 6.11 ImplÃ©menter KEYWORDS arguments (2-3 jours) - OPTIONNEL
    PrioritÃ© : â­â­â­ Moyenne  |  ComplexitÃ© : â­â­â­â­ Ã‰levÃ©e
    
    âš ï¸ NON CRITIQUE : Peut utiliser args positionnels
    
    Approche :
      - Parser &key dans (defun f (a &key (b 10) c) ...)
      - GÃ©nÃ©ration code pour valeurs dÃ©faut
      - Parsing arguments lors appel
    
    ALTERNATIVE : Refactoriser appels avec args positionnels uniquement
    RECOMMANDATION : SKIP (dÃ©jÃ  fait dans vm-compilable.lisp âœ…)

Total Sprint 4 : 0-2 jours (si on skip LOOP/FORMAT/KEYWORDS dÃ©jÃ  faits)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PLAN DE DÃ‰VELOPPEMENT OPTIMISÃ‰

Sprints obligatoires (constructions critiques) :
  â€¢ Sprint 1 : WHEN/UNLESS, INCF/DECF, ERROR (1-2 jours)
  â€¢ Sprint 2 : LIST OPS + DOLIST (3-5 jours)
  â€¢ Sprint 3 : Registres tableau fixe (1 jour, dÃ©jÃ  fait âœ…)
  
  Total minimum : 5-8 jours

Sprints optionnels (dÃ©jÃ  contournÃ©s dans vm-compilable.lisp) :
  â€¢ DEFSTRUCT : SKIP (dÃ©jÃ  refactorisÃ© âœ…)
  â€¢ HASH-TABLES : SKIP (remplacÃ© par tableau âœ…)
  â€¢ LOOP : SKIP (transformÃ© en WHILE âœ…)
  â€¢ FORMAT : SKIP (supprimÃ© âœ…)
  â€¢ KEYWORDS : SKIP (refactorisÃ© âœ…)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROCHAINES Ã‰TAPES IMMÃ‰DIATES

[ ] 6.12 Compiler les fonctions auxiliaires simples
    Ordre :
      1. get-value, set-value
      2. mem-read, mem-write
      3. get-register, set-register (dÃ©jÃ  testÃ©s comme intrinsÃ¨ques)

[ ] 6.7 Compiler execute-instruction
    Dispatcher avec case (maintenant supportÃ©)
    Appels aux fonctions execute-add, execute-sub, etc.

[ ] 6.8 Compiler run-vm (boucle principale)
    Code LISP :
      (defun run-vm ()
        (loop while (eq *vm-state* :running)
          do (execute-instruction)))
    
    Code MIPS :
      RUN_VM_LOOP:
        LW $T0 vm_state
        LI $T1 1          ; :running = 1
        BNE $T0 $T1 RUN_VM_END
        JAL EXECUTE_INSTRUCTION
        J RUN_VM_LOOP
      RUN_VM_END:
        JR $RA

[ ] 6.9 GÃ©nÃ©rer le fichier MIPS complet
    Fichier : vm1-compilation/generated/vm1.mips
    
    Structure :
      .data
        vm_memory: .space 4194304  ; 4 Mo
        vm_state: .word 1
        vm_pc: .word 0
        vm_registers: .space 160   ; 40 registres
      
      .text
        main:
          JAL RUN_VM
          HALT
        
        ; Fonctions...
        GET_VALUE:
          ...
        EXECUTE_INSTRUCTION:
          ...
        RUN_VM:
          ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 7 : TESTS (3-4h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 7.1 Test de chargement
    [ ] Charger vm1.mips dans VMâ‚€
    [ ] VÃ©rifier pas d'erreurs de syntaxe

[ ] 7.2 Test simple : (+ 2 3)
    Ã‰tapes :
      1. Compiler (+ 2 3) â†’ code_prog (MIPS)
      2. Charger code_prog dans mÃ©moire de VMâ‚
      3. Charger VMâ‚ (vm1.mips) dans VMâ‚€
      4. VMâ‚€ exÃ©cute VMâ‚ qui exÃ©cute code_prog
      5. RÃ©sultat attendu : 5

[ ] 7.3 Test complexe : let + if
    Programme : (let ((x 10)) (if (> x 5) (* x 2) (+ x 1)))
    RÃ©sultat attendu : 20

[ ] 7.4 Tests performance
    Comparer : LISP natif vs VMâ‚€ vs VMâ‚ (vraie)
    Fichier : vm1-compilation/benchmarks/vm1-real-performance.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 8 : DOCUMENTATION (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 8.1 Documenter le processus
    Fichier : vm1-compilation/README_VM1.md

[ ] 8.2 Script de build
    Fichier : vm1-compilation/build-vm1.lisp
    
    Automatise :
      1. Chargement compilateur Ã©tendu
      2. Compilation vm-compilable.lisp
      3. GÃ©nÃ©ration vm1.mips
      4. Tests automatiques

[ ] 8.3 RÃ©sultats finaux
    Benchmarks et analyse

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RÃ‰SUMÃ‰ DES EXTENSIONS NÃ‰CESSAIRES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Compilateur - Extensions supportÃ©es :
  âœ… ArithmÃ©tique : +, -, *, /, <, >, =, <=, >=
  âœ… ContrÃ´le : if, let, setq
  âœ… Fonctions : defun, appels, rÃ©cursion
  âœ… WHILE loops (Phase 2) - 10/10 tests passent
  âœ… PROGN sequences (Phase 2 bonus)
  âœ… ARRAYS : make-array, aref, setf aref (Phase 3) - 12/12 tests passent
  âœ… CASE (dÃ©jÃ  supportÃ© depuis phases prÃ©cÃ©dentes)
  âœ… CLOSURES (Phase 9)
  âœ… LABELS (fonctions locales)

VM - Simplifications Ã  faire :
  ğŸ”„ Defstruct â†’ Variables globales (Phase 5 en cours)
  âœ… Hash-table â†’ Array (TransformÃ© dans vm-compilable.lisp)
  âœ… DOLIST â†’ WHILE indexÃ© (TransformÃ© dans vm-compilable.lisp)
  âœ… LOOP â†’ WHILE (TransformÃ© dans vm-compilable.lisp)
  âœ… FORMAT â†’ Suppression (~40 occurrences supprimÃ©es)
  âœ… Keywords â†’ Constantes numÃ©riques (tous remplacÃ©s)

Statistiques :
  â€¢ Lignes de code ajoutÃ©es pour ARRAYS : +234 (compiler) +450 (doc) +155 (tests)
  â€¢ Lignes de code ajoutÃ©es pour WHILE : ~80 (compiler) +165 (tests)
  â€¢ Transformations VM : ~150 rÃ©fÃ©rences vm supprimÃ©es, 0 constructs non-supportÃ©s
  â€¢ Tests passant : 22/22 (10 WHILE + 12 ARRAYS) = 100%
  â€¢ Fichier vm-compilable.lisp : ~690 lignes, chargement OK

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTIMATION TEMPORELLE - MISE Ã€ JOUR 27 NOVEMBRE 2025 (20:45) - OPTION A
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ NOUVELLE STRATÃ‰GIE : OPTION A (Compilation ComplÃ¨te)

PHASES INITIALES (TERMINÃ‰ES)                EstimÃ©    RÃ©el      Status
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Phase 1 : Analyse                           2-3h      2h        âœ… TERMINÃ‰
Phase 2 : Boucles (WHILE)                   3-4h      2h        âœ… TERMINÃ‰
Phase 3 : Arrays                            2-3h      2.5h      âœ… TERMINÃ‰
Phase 4 : Case                              2-3h      0h        âœ… DÃ‰JÃ€ FAIT
Phase 5 : Simplification VM                 5-6h      2.5h      âœ… TERMINÃ‰
Phase 6 : Compilation VM (partielle)        4-5h      9.5h      âœ… TERMINÃ‰
  â€¢ Session 1-3 : Extensions                -         5.5h      âœ… TERMINÃ‰
  â€¢ Session 4 : Bug fix DEFUN               -         2h        âœ… TERMINÃ‰
  â€¢ Session 5 : Tests & Analyse             -         2h        âœ… TERMINÃ‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL PHASES INITIALES                      18-24h    18.5h     âœ… 100%

NOUVELLE FEUILLE DE ROUTE - OPTION A        EstimÃ©    RÃ©el      Status
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Sprint 1 : Constructions simples            1-2j      -         â¸ï¸ Ã€ FAIRE
  â€¢ WHEN/UNLESS                             4-6h      -         [ ]
  â€¢ INCF/DECF/PUSH/POP                      4-6h      -         [ ]
  â€¢ ERROR â†’ PRINT+HALT                      2-4h      -         [ ]

Sprint 2 : Manipulation de listes           3-5j      -         â¸ï¸ Ã€ FAIRE
  â€¢ LIST OPS (CONS/CAR/CDR/NULL)            2-4j      -         [ ]
  â€¢ DOLIST                                  1j        -         [ ]

Sprint 3 : Structures de donnÃ©es            1j        -         â¸ï¸ Ã€ FAIRE
  â€¢ Registres tableau fixe (dÃ©jÃ  fait âœ…)   0h        0h        âœ… SKIP
  â€¢ DEFSTRUCT (dÃ©jÃ  contournÃ© âœ…)           0h        0h        âœ… SKIP
  â€¢ HASH-TABLES (dÃ©jÃ  remplacÃ© âœ…)          0h        0h        âœ… SKIP

Sprint 4 : Features avancÃ©es (optionnel)    0-2j      -         â¸ï¸ SKIP
  â€¢ LOOP (dÃ©jÃ  transformÃ© âœ…)               0h        0h        âœ… SKIP
  â€¢ FORMAT (dÃ©jÃ  supprimÃ© âœ…)               0h        0h        âœ… SKIP
  â€¢ KEYWORDS (dÃ©jÃ  refactorisÃ© âœ…)          0h        0h        âœ… SKIP

Phase 7 : Tests & Compilation finale        2-3j      -         â¸ï¸ Ã€ FAIRE
  â€¢ Tests incrÃ©mentaux par Sprint           -         -         [ ]
  â€¢ Compilation vm-compilable.lisp          1j        -         [ ]
  â€¢ Tests end-to-end VM1+VM2                1j        -         [ ]
  â€¢ Benchmarks performance                  0.5j      -         [ ]

Phase 8 : Documentation                     1j        -         â¸ï¸ Ã€ FAIRE
  â€¢ Documentation constructions             0.5j      -         [ ]
  â€¢ Guides utilisateur                      0.5j      -         [ ]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL OPTION A (OPTIMAL)                    7-13j     -         â¸ï¸ 0%
                                           (56-104h)

TOTAL GÃ‰NÃ‰RAL (Phases initiales + Option A)
                                           10-17j     18.5h     â¸ï¸ 11%
                                          (80-136h)  (1.5-2.3j)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ANALYSE DES TEMPS

Temps Ã©conomisÃ©s grÃ¢ce aux optimisations :
  âœ… DEFSTRUCT contournÃ© (vm-compilable.lisp) : -5-7 jours
  âœ… HASH-TABLES remplacÃ© par tableau fixe : -3-5 jours
  âœ… LOOP transformÃ© manuellement : -1-2 jours
  âœ… FORMAT supprimÃ© : -1-2 jours
  âœ… KEYWORDS refactorisÃ©s : -2-3 jours
  
  Total Ã©conomisÃ© : 12-19 jours ğŸ‰
  
  Estimation si implÃ©mentation complÃ¨te : 35 jours â†’ 13 jours (rÃ©duction 63%)

Temps rÃ©el vs estimation initiale :
  â€¢ Estimation initiale Phase 11 : 25-32h
  â€¢ Temps investi phases initiales : 18.5h
  â€¢ Estimation restante Option A optimisÃ©e : 56-104h (7-13 jours)
  â€¢ Total Option A : 74.5-122.5h (9-15 jours)
  
  DiffÃ©rence : Option A nÃ©cessite 3-5x plus de temps que prÃ©vu initialement,
              mais reste 2-3x plus rapide que l'implÃ©mentation naÃ¯ve complÃ¨te

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROGRESSION GLOBALE PHASE 11 (OPTION A) : ~11% â¸ï¸

âœ… Analyse VM (100%)
âœ… WHILE loops (100% - 10/10 tests)
âœ… PROGN (100%)
âœ… ARRAYS (100% - 12/12 tests)
âœ… VM Simplification (100% - vm-compilable.lisp crÃ©Ã©, ~690 lignes)
âœ… Tests & Benchmarks (100% - 5/5 tests, VM0 analysÃ©)
â¸ï¸ Sprint 1 : Constructions simples (0%) - WHEN/UNLESS/INCF/ERROR
â¸ï¸ Sprint 2 : Listes (0%) - CONS/CAR/CDR/DOLIST
â¸ï¸ Sprint 3 : Structures (100% dÃ©jÃ  fait âœ…) - SKIP
â¸ï¸ Sprint 4 : AvancÃ© (100% dÃ©jÃ  fait âœ…) - SKIP
â¸ï¸ Phase 7 : Tests finaux (0%)
â¸ï¸ Phase 8 : Documentation (0%)

Extensions implÃ©mentÃ©es : 22/22 tests passing (100%)
Constructions Lisp supportÃ©es : 8/25 (32%)
Objectif Option A : 17/25 (68% - suffisant pour vm-compilable.lisp)

PROCHAINE SESSION : Sprint 1.1 - ImplÃ©menter WHEN/UNLESS (4-6h)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
