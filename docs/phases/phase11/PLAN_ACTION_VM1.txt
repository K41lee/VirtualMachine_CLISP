â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PLAN SIMPLIFIÃ‰ - PHASE 11 VMâ‚                            â•‘
â•‘                     Compiler VM en MIPS                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Date: 27 novembre 2025 - Mise Ã  jour aprÃ¨s implÃ©mentation ARRAYS
DurÃ©e estimÃ©e: 25-32 heures (rÃ©duit grÃ¢ce aux extensions dÃ©jÃ  implÃ©mentÃ©es)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARCHITECTURE CLARIFIÃ‰E
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚  VMâ‚€ (Native)  =  src/vm.lisp exÃ©cutÃ©e en LISP natif                 â”‚
â”‚  VMâ‚ (CompilÃ©e) =  src/vm.lisp compilÃ©e en MIPS, chargÃ©e dans VMâ‚€    â”‚
â”‚                                                                        â”‚
â”‚  C'est la MÃŠME VM, juste deux versions :                             â”‚
â”‚    - VMâ‚€ : InterprÃ©teur LISP natif                                   â”‚
â”‚    - VMâ‚ : Code MIPS dans mÃ©moire de VMâ‚€                             â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Flux d'exÃ©cution :
  Programme LISP â†’ Compilateur â†’ Code MIPS (code_prog)
                                      â†“
                              VMâ‚ (en MIPS) charge code_prog
                                      â†“
                              VMâ‚€ (native) exÃ©cute VMâ‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FICHIERS DU PROJET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FICHIERS PRINCIPAUX (Ã  utiliser pour Phase 11)
â”œâ”€â”€ src/vm.lisp                 â† BASE POUR VMâ‚ (686 lignes)
â”œâ”€â”€ src/compiler.lisp           â† Compilateur Ã  Ã©tendre
â”œâ”€â”€ src/loader.lisp             â† Loader pour charger code
â”œâ”€â”€ src/asm-ops.lisp            â† Opcodes et constantes
â””â”€â”€ src/utils.lisp              â† Utilitaires

FICHIERS BOOTSTRAP (Phase 10 - rÃ©fÃ©rence historique uniquement)
â”œâ”€â”€ src/bootstrap/vm-bootstrap.lisp          (version sans debug)
â”œâ”€â”€ src/bootstrap/compiler-bootstrap.lisp    (gÃ©nÃ©rÃ© = identique)
â”œâ”€â”€ src/bootstrap/loader-bootstrap.lisp      (version sans debug)
â””â”€â”€ src/bootstrap/primitives.lisp            (fonctions LISP pures)

Note: Les fichiers bootstrap ne sont PAS nÃ©cessaires pour Phase 11
      Ils sont gardÃ©s pour historique Phase 10 uniquement

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 1 : ANALYSE src/vm.lisp âœ… TERMINÃ‰ (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 1.1 Lister toutes les fonctions de vm.lisp
    AnalysÃ© : 687 lignes
    RÃ©sultat : 35 fonctions identifiÃ©es
    Fichier : docs/phases/phase11/ANALYSE_VM_CONSTRUCTS.txt

[âœ…] 1.2 Identifier les constructions LISP utilisÃ©es
    RÃ©sultats dÃ©taillÃ©s dans : docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
    TrouvÃ© :
      - DEFSTRUCT (vm) : 1 occurrence â†’ Variables globales
      - HASH-TABLE : 4 usages â†’ Arrays avec indices
      - DOLIST : 2 occurrences â†’ WHILE indexÃ©
      - LOOP : 3 occurrences â†’ WHILE
      - FORMAT : ~40 occurrences â†’ Suppression
      - CASE : OK (dÃ©jÃ  supportÃ©)

[âœ…] 1.3 CrÃ©er une liste de dÃ©pendances
    Fichiers crÃ©Ã©s :
      - docs/phases/phase11/ANALYSE_VM_CONSTRUCTS.txt
      - docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
      - docs/phases/phase11/PLAN_SIMPLIFICATION_VM.txt
    
    Extensions critiques identifiÃ©es :
      âœ… WHILE loops (implÃ©mentÃ© - 10/10 tests)
      âœ… PROGN sequences (implÃ©mentÃ©)
      âœ… ARRAYS (implÃ©mentÃ© - 12/12 tests)
      â¸ï¸ DOLIST (ne sera PAS implÃ©mentÃ© - voir stratÃ©gie alternative)
      âœ… CASE (dÃ©jÃ  supportÃ© dans compilateur)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 2 : BOUCLES âœ… TERMINÃ‰ (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 2.1 ImplÃ©menter WHILE dans le compilateur
    Fichier : src/compiler.lisp (fonction compile-while, ligne ~1220)
    Documentation : src/compiler-extensions/compile-while.lisp
    
    Syntaxe implÃ©mentÃ©e :
      (while condition body...)
    
    GÃ©nÃ©ration MIPS :
      WHILE_START:
        ; Ã©valuer condition â†’ $V0
        BEQ $V0 $ZERO WHILE_END
        ; exÃ©cuter body (avec PROGN si multiple)
        J WHILE_START
      WHILE_END:
        MOVE $ZERO $V0  ; retourne NIL
    
    Tests : tests/unit/test-while.lisp
      [âœ…] Boucle simple compteur
      [âœ…] Accumulation valeurs
      [âœ…] Condition fausse initialement
      [âœ…] Condition nil
      [âœ…] Multi-instructions dans body
      [âœ…] Boucles imbriquÃ©es
      [âœ…] Calcul factorielle
      [âœ…] Conditions AND
      [âœ…] Double condition
      [âœ…] Retourne nil
    
    RÃ©sultat : 10/10 tests passent âœ…

[âœ…] 2.2 IntÃ©grer WHILE dans src/compiler.lisp
    AjoutÃ© clause (:while ...) dans compile-expr (ligne ~1916)
    Parser WHILE ajoutÃ© (ligne ~295)

[âœ…] 2.3 BONUS : ImplÃ©menter PROGN
    NÃ©cessaire pour body WHILE avec plusieurs expressions
    Fonction compile-progn ajoutÃ©e (ligne ~1283)
    Parser PROGN ajoutÃ© (ligne ~303)
    Tests : IntÃ©grÃ©s dans test-while.lisp

Note: LOOP de Common Lisp sera transformÃ© en WHILE dans vm-compilable.lisp

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 3 : ARRAYS âœ… TERMINÃ‰ (2h30)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 3.1 ImplÃ©menter ARRAYS
    Fichiers :
      - src/compiler.lisp : Fonctions compile-make-array (ligne ~1307),
                           compile-aref (ligne ~1405),
                           compile-setf-aref (ligne ~1426)
      - Documentation : src/compiler-extensions/compile-arrays.lisp (450 lignes)
    
    Fonctions implÃ©mentÃ©es :
      (make-array size [:initial-element value]) â†’ Allocation tas avec $gp
      (aref array index)                         â†’ Lecture Ã©lÃ©ment
      (setf (aref array index) value)           â†’ Ã‰criture Ã©lÃ©ment
    
    ImplÃ©mentation MIPS :
      make-array :
        - Structure : [MAGIC(0xA88A)][SIZE][elem0][elem1]...[elemN]
        - Allouer (2 + size) mots avec $gp (Global Pointer)
        - Initialisation optionnelle avec boucle WHILE
        - Retourne adresse de base dans $V0
      
      aref :
        - Calculer offset = index + 2 (pour header)
        - Adresse effective = base + offset
        - LW value de l'adresse (offset 0)
      
      setf aref :
        - MÃªme calcul d'adresse
        - SW value Ã  l'adresse
        - Retourne value (comportement SETF)

    Tests : tests/unit/test-arrays.lisp (155 lignes)
      [âœ…] CrÃ©er array de taille 5
      [âœ…] Lire Ã©lÃ©ment par dÃ©faut (sans init)
      [âœ…] CrÃ©er avec :initial-element 42
      [âœ…] Lire diffÃ©rents indices (init 99)
      [âœ…] Ã‰crire avec setf aref
      [âœ…] Ã‰crire index 3, lire index 3
      [âœ…] Ã‰lÃ©ments indÃ©pendants
      [âœ…] Boucle WHILE remplissage array
      [âœ…] Accumuler valeurs array avec WHILE
      [âœ…] Array avec calculs (carrÃ©s)
      [âœ…] CrÃ©er plusieurs arrays indÃ©pendants
      [âœ…] SETF AREF retourne la valeur assignÃ©e
    
    RÃ©sultat : 12/12 tests passent âœ…

[âœ…] 3.2 IntÃ©grer dans src/compiler.lisp
    - Parser make-array ajoutÃ© (ligne ~307)
    - Parser aref ajoutÃ© (ligne ~314)
    - Parser setf aref ajoutÃ© (ligne ~330, dÃ©tection dans case setq)
    - Clauses compile-expr : :make-array (ligne ~1930), :aref (ligne ~1933),
                            :setf-aref (ligne ~1942)
    - Registres t4-t7 ajoutÃ©s (ligne 15-18)
    - Support $gp dans get-reg (src/asm-ops.lisp, ligne 139)

    Code ajoutÃ© : +234 lignes dans src/compiler.lisp
                 +1 ligne dans src/asm-ops.lisp

Documentation complÃ¨te : docs/phases/phase11/IMPLEMENTATION_ARRAYS.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 4 : CASE âœ… DÃ‰JÃ€ SUPPORTÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 4.1 CASE dÃ©jÃ  implÃ©mentÃ©
    Le compilateur supporte dÃ©jÃ  CASE depuis les phases prÃ©cÃ©dentes
    Fichier : src/compiler.lisp
    
    Syntaxe supportÃ©e :
      (case expr
        (val1 body1)
        (val2 body2)
        (t default))
    
    ImplÃ©mentation :
      - Parser dans parse-lisp-expr
      - Fonction compile-case existante
      - GÃ©nÃ¨re des labels et branches BEQ pour chaque cas
      - Support du cas default avec (t ...)

[âœ…] 4.2 DÃ©jÃ  intÃ©grÃ© dans src/compiler.lisp
    Clause (:case ...) prÃ©sente dans compile-expr

Note : CASE est utilisÃ© massivement dans execute-instruction de vm.lisp
       pour dispatcher les 40+ opcodes. Pas de modifications nÃ©cessaires.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 5 : SIMPLIFIER DEFSTRUCT ET HASH-TABLES âœ… TERMINÃ‰ (2h30)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[âœ…] 5.0 Analyse et planification
    Fichiers crÃ©Ã©s :
      - docs/phases/phase11/PLAN_SIMPLIFICATION_VM.txt
      - docs/phases/phase11/ANALYSE_TRANSFORMATIONS_VM.txt
      - src/compiler-extensions/compile-dolist.lisp (stratÃ©gie alternative)
    
    Transformations identifiÃ©es :
      â€¢ DEFSTRUCT â†’ Variables globales (1 occurrence)
      â€¢ HASH-TABLE â†’ Arrays avec indices (4 usages)
      â€¢ DOLIST â†’ WHILE indexÃ© (2 occurrences)
      â€¢ LOOP â†’ WHILE (3 occurrences)
      â€¢ FORMAT â†’ Suppression (~40 occurrences)
      â€¢ Keywords â†’ Constantes numÃ©riques
    
    Estimation initiale : 5h45
    Temps rÃ©el : 2h30

[âœ…] 5.1 CrÃ©er src/vm-compilable.lisp (âœ… FAIT)
    Copie de src/vm.lisp (687 lignes) avec simplifications :
    
    âœ… Ã‰tape 1 : DÃ©finir constantes et variables globales
      - Constantes d'Ã©tat : +state-ready+ (0), +state-running+ (1),
                           +state-halted+ (2), +state-error+ (3)
      - Variables globales : *vm-memory*, *vm-registers*, *vm-state*,
                            *vm-instruction-count*, *vm-verbose*
    
    âœ… Ã‰tape 2 : Supprimer DEFSTRUCT et accesseurs
      - (defstruct vm) supprimÃ©
      - ParamÃ¨tre (vm) supprimÃ© de TOUTES les fonctions
      - ~150 rÃ©fÃ©rences transformÃ©es
    
    âœ… Ã‰tape 3 : Remplacer HASH-TABLE par ARRAY
      - Fonction reg-index crÃ©Ã©e (42 registres: 0-31 gÃ©nÃ©raux, 32-41 spÃ©ciaux)
      - Tous les gethash remplacÃ©s par aref + reg-index
      - Tous les setf/gethash remplacÃ©s par setq/aref
    
    âœ… Ã‰tape 4 : Transformer DOLIST (2 occurrences)
      - init-registers: WHILE avec compteur 0-41
      - dump-registers: fonction dÃ©sactivÃ©e (retourne T)
    
    âœ… Ã‰tape 5 : Transformer LOOP (3 occurrences)
      - run-vm: LOOP â†’ WHILE avec condition sur *vm-state*
      - dump-memory/dump-stack: fonctions dÃ©sactivÃ©es
    
    âœ… Ã‰tape 6 : Supprimer FORMAT (~40 occurrences)
      - Tous les (format t ...) supprimÃ©s
      - Blocs (when (vm-verbose vm) ...) supprimÃ©s
      - Script Python pour suppression automatique
    
    âœ… Ã‰tape 7 : Remplacer keywords par constantes
      - Tous les :ready/:running/:halted/:error remplacÃ©s
      - Comparaisons (eq state :running) â†’ (= state +state-running+)

[âœ…] 5.2 Remplacer ERROR et HANDLER-CASE
    - HANDLER-CASE supprimÃ© de run-vm
    - Gestion d'erreur simplifiÃ©e avec changement d'Ã©tat
    - (error "msg") remplacÃ© par (setq *vm-state* +state-error+)

[âœ…] 5.3 Tester vm-compilable.lisp en LISP natif
    âœ“ Chargement : (load "src/vm-compilable.lisp") â†’ SUCCÃˆS
    âœ“ Pas d'erreurs de syntaxe
    âœ“ ~690 lignes (vs 687 dans vm.lisp)
    
    Note: Tests complets impossibles sans WHILE (extension compilateur)
    Fichier : docs/phases/phase11/PHASE5_SIMPLIFICATION_COMPLETE.txt

[âœ…] 5.4 VÃ©rifications finales
    âœ… Pas de DEFSTRUCT
    âœ… Pas de HASH-TABLE / GETHASH
    âœ… Pas de DOLIST
    âœ… Pas de LOOP
    âœ… Pas de FORMAT
    âœ… Pas de keywords d'Ã©tat
    âœ… Pas de SETF (remplacÃ© par SETQ)
    âœ… Pas de INCF/DECF
    âœ… Pas de HANDLER-CASE
    
    Constructions utilisÃ©es (toutes supportÃ©es) :
      âœ“ DEFUN, DEFVAR, DEFCONSTANT, LET, PROGN
      âœ“ WHILE, CASE, COND, WHEN, SETQ, AREF, MAKE-ARRAY
      âœ“ ArithmÃ©tique, comparaisons, logique, RETURN-FROM

RÃ©sultat Phase 5 : âœ… SUCCÃˆS
  Fichier : src/vm-compilable.lisp (~690 lignes)
  Ã‰tat : PrÃªt pour compilation en MIPS
  Documentation : docs/phases/phase11/PHASE5_SIMPLIFICATION_COMPLETE.txt

Tests de base (Note: nÃ©cessitent chargement du compilateur pour WHILE) :
      [ ] (+ 2 3) â†’ 5
      [ ] (let ((x 10)) (* x 2)) â†’ 20
      [ ] Boucle simple

Note : Les opcodes restent des keywords (:ADD, :SUB, etc.) car dÃ©jÃ 
       supportÃ©s par CASE. Pas besoin de les encoder en entiers.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 6 : COMPILATION VM (4-5h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 6.1 Compiler les fonctions auxiliaires
    Ordre :
      1. get-value, set-value
      2. mem-read, mem-write
      3. get-register, set-register

[ ] 6.2 Compiler execute-instruction
    Dispatcher avec case (maintenant supportÃ©)
    Appels aux fonctions execute-add, execute-sub, etc.

[ ] 6.3 Compiler run-vm (boucle principale)
    Code LISP :
      (defun run-vm ()
        (loop while (eq *vm-state* :running)
          do (execute-instruction)))
    
    Code MIPS :
      RUN_VM_LOOP:
        LW $T0 vm_state
        LI $T1 1          ; :running = 1
        BNE $T0 $T1 RUN_VM_END
        JAL EXECUTE_INSTRUCTION
        J RUN_VM_LOOP
      RUN_VM_END:
        JR $RA

[ ] 6.4 GÃ©nÃ©rer le fichier MIPS complet
    Fichier : vm1-compilation/generated/vm1.mips
    
    Structure :
      .data
        vm_memory: .space 4194304  ; 4 Mo
        vm_state: .word 1
        vm_pc: .word 0
        vm_registers: .space 160   ; 40 registres
      
      .text
        main:
          JAL RUN_VM
          HALT
        
        ; Fonctions...
        GET_VALUE:
          ...
        EXECUTE_INSTRUCTION:
          ...
        RUN_VM:
          ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 7 : TESTS (3-4h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 7.1 Test de chargement
    [ ] Charger vm1.mips dans VMâ‚€
    [ ] VÃ©rifier pas d'erreurs de syntaxe

[ ] 7.2 Test simple : (+ 2 3)
    Ã‰tapes :
      1. Compiler (+ 2 3) â†’ code_prog (MIPS)
      2. Charger code_prog dans mÃ©moire de VMâ‚
      3. Charger VMâ‚ (vm1.mips) dans VMâ‚€
      4. VMâ‚€ exÃ©cute VMâ‚ qui exÃ©cute code_prog
      5. RÃ©sultat attendu : 5

[ ] 7.3 Test complexe : let + if
    Programme : (let ((x 10)) (if (> x 5) (* x 2) (+ x 1)))
    RÃ©sultat attendu : 20

[ ] 7.4 Tests performance
    Comparer : LISP natif vs VMâ‚€ vs VMâ‚ (vraie)
    Fichier : vm1-compilation/benchmarks/vm1-real-performance.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PHASE 8 : DOCUMENTATION (2h)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[ ] 8.1 Documenter le processus
    Fichier : vm1-compilation/README_VM1.md

[ ] 8.2 Script de build
    Fichier : vm1-compilation/build-vm1.lisp
    
    Automatise :
      1. Chargement compilateur Ã©tendu
      2. Compilation vm-compilable.lisp
      3. GÃ©nÃ©ration vm1.mips
      4. Tests automatiques

[ ] 8.3 RÃ©sultats finaux
    Benchmarks et analyse

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RÃ‰SUMÃ‰ DES EXTENSIONS NÃ‰CESSAIRES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Compilateur - Extensions supportÃ©es :
  âœ… ArithmÃ©tique : +, -, *, /, <, >, =, <=, >=
  âœ… ContrÃ´le : if, let, setq
  âœ… Fonctions : defun, appels, rÃ©cursion
  âœ… WHILE loops (Phase 2) - 10/10 tests passent
  âœ… PROGN sequences (Phase 2 bonus)
  âœ… ARRAYS : make-array, aref, setf aref (Phase 3) - 12/12 tests passent
  âœ… CASE (dÃ©jÃ  supportÃ© depuis phases prÃ©cÃ©dentes)
  âœ… CLOSURES (Phase 9)
  âœ… LABELS (fonctions locales)

VM - Simplifications Ã  faire :
  ğŸ”„ Defstruct â†’ Variables globales (Phase 5 en cours)
  âœ… Hash-table â†’ Array (TransformÃ© dans vm-compilable.lisp)
  âœ… DOLIST â†’ WHILE indexÃ© (TransformÃ© dans vm-compilable.lisp)
  âœ… LOOP â†’ WHILE (TransformÃ© dans vm-compilable.lisp)
  âœ… FORMAT â†’ Suppression (~40 occurrences supprimÃ©es)
  âœ… Keywords â†’ Constantes numÃ©riques (tous remplacÃ©s)

Statistiques :
  â€¢ Lignes de code ajoutÃ©es pour ARRAYS : +234 (compiler) +450 (doc) +155 (tests)
  â€¢ Lignes de code ajoutÃ©es pour WHILE : ~80 (compiler) +165 (tests)
  â€¢ Transformations VM : ~150 rÃ©fÃ©rences vm supprimÃ©es, 0 constructs non-supportÃ©s
  â€¢ Tests passant : 22/22 (10 WHILE + 12 ARRAYS) = 100%
  â€¢ Fichier vm-compilable.lisp : ~690 lignes, chargement OK

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTIMATION TEMPORELLE - MISE Ã€ JOUR 27 NOVEMBRE 2025 (11:35)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                                    EstimÃ©    RÃ©el      Status
Phase 1 : Analyse               2-3h      2h        âœ… TERMINÃ‰
Phase 2 : Boucles (WHILE)       3-4h      2h        âœ… TERMINÃ‰
Phase 3 : Arrays                2-3h      2.5h      âœ… TERMINÃ‰
Phase 4 : Case                  2-3h      0h        âœ… DÃ‰JÃ€ FAIT
Phase 5 : Simplification VM     5-6h      2.5h      âœ… TERMINÃ‰
Phase 6 : Compilation VM        4-5h      -         â¸ï¸ Ã€ FAIRE
Phase 7 : Tests                 3-4h      -         â¸ï¸ Ã€ FAIRE
Phase 8 : Documentation         2h        -         â¸ï¸ Ã€ FAIRE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL                          23-30h    9h        ~40% COMPLÃ‰TÃ‰
                                         (~14-21h restantes)

Temps gagnÃ© grÃ¢ce aux extensions dÃ©jÃ  implÃ©mentÃ©es et efficacitÃ© : ~8h
  - CASE dÃ©jÃ  supportÃ© : -2h
  - WHILE plus rapide que prÃ©vu : -1h
  - Documentation dÃ©jÃ  faite : -2h
  - Phase 5 plus rapide que prÃ©vu (sed/scripts) : -3h

Estimation rÃ©visÃ©e totale : 18-24h (au lieu de 25-32h)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROGRESSION GLOBALE PHASE 11 : ~40% â©

âœ… Analyse VM (100%)
âœ… WHILE loops (100% - 10/10 tests)
âœ… PROGN (100%)
âœ… ARRAYS (100% - 12/12 tests)
âœ… DOLIST analyse (100% - dÃ©cision: ne pas implÃ©menter)
âœ… VM Simplification (100% - vm-compilable.lisp crÃ©Ã©, ~690 lignes)
â¸ï¸ Compilation VM â†’ MIPS (0%)
â¸ï¸ Tests VMâ‚ dans VMâ‚€ (0%)

Extensions totales implÃ©mentÃ©es : 22/22 tests passing (100%)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
