================================================================================
                      HISTORIQUE DU DÉVELOPPEMENT
          Phases de Développement et Améliorations Successives
================================================================================

Date : 20 novembre 2025

Ce document retrace chronologiquement le développement du projet :
- Phase 2 : Appels de fonction MIPS (JAL/JR)
- Phase 3 : Compilateur LISP → MIPS
- Phase 5 : Finalisation compilateur
- Amélioration : Gestion dynamique registres
- Modularisation : Séparation tests

================================================================================
                    PHASE 2 : APPELS DE FONCTION MIPS
================================================================================

Date de finalisation : 20 novembre 2025
Statut : ✓✓✓ COMPLÉTÉE

OBJECTIF :
----------
Implémenter les instructions JAL/JR et la gestion complète des appels
de fonction selon les conventions MIPS.

PRIORITÉ 1 : INSTRUCTIONS JAL/JR ✓
-----------------------------------

JAL (Jump And Link) :
- Sauvegarde $pc + 1 dans $ra
- Branche vers label fonction
- Permet retour avec JR $ra

JR (Jump Register) :
- Branche vers adresse dans registre
- Utilisé pour retour fonction : JR $ra
- Restaure exécution après JAL

Implémentation vm.lisp :
  (:JAL 
    (let ((label (first args))
          (pc-reg (get-reg :pc))
          (ra-reg (get-reg :ra)))
      (set-register vm ra-reg (+ (get-register vm pc-reg) 1))
      (let ((target-addr (gethash label (vm-labels vm))))
        (if target-addr
            (set-register vm pc-reg target-addr)
            (error "Label inconnu: ~A" label)))))
  
  (:JR
    (let ((reg (first args))
          (pc-reg (get-reg :pc)))
      (set-register vm pc-reg (get-register vm reg))))

Tests réalisés :
✓ Appel fonction simple
✓ Retour de fonction
✓ Appels imbriqués

PRIORITÉ 2 : GESTION FRAMES MIPS ✓
-----------------------------------

Prologue de fonction :
- Allouer espace pile : ADDI $sp -frame_size $sp
- Sauvegarder $ra : SW $ra $sp 0
- Sauvegarder arguments : SW $a0-$a3
- Charger paramètres : LW → $s0-$s7

Épilogue de fonction :
- Restaurer $ra : LW $sp 0 $ra
- Libérer pile : ADDI $sp +frame_size $sp
- Retourner : JR $ra

Instructions PUSH/POP ajoutées :
  (PUSH $rs) ≡ ADDI $sp -4 $sp + SW $rs $sp 0
  (POP $rd) ≡ LW $sp 0 $rd + ADDI $sp 4 $sp

PRIORITÉ 3 : CONVENTIONS D'APPEL ✓
-----------------------------------

Arguments fonction :
- 4 premiers : $a0, $a1, $a2, $a3
- Suivants : sur pile (si nécessaire)

Valeurs retour :
- Principale : $v0
- Secondaire : $v1 (optionnel)

Sauvegarde registres :
- Caller-saved : $t0-$t9, $a0-$a3, $v0-$v1
  → Appelant sauvegarde si besoin après appel
  
- Callee-saved : $s0-$s7, $ra, $fp, $sp
  → Fonction sauvegarde/restaure si modifie

EXEMPLES CRÉÉS :
----------------

1. example-mips-jal-jr :
   Appel fonction simple qui retourne valeur

2. example-mips-nested-calls :
   Fonction A appelle fonction B

3. example-mips-countdown-recursive :
   Countdown(5) → affiche 5, 4, 3, 2, 1, 0

4. example-mips-fibonacci-recursive :
   fib(6) = 8 avec récursivité double

TESTS AJOUTÉS :
---------------
✓ test-jal-jr : Basique JAL/JR
✓ test-jal-jr-with-stack : Avec pile
✓ test-nested-calls : Appels imbriqués

RÉSULTATS :
-----------
✓ Tous tests passent (100%)
✓ Fibonacci récursif fonctionne
✓ Countdown récursif fonctionne
✓ Appels imbriqués fonctionnent
✓ Sauvegarde/restauration $ra OK

================================================================================
                    PHASE 3 : COMPILATEUR LISP → MIPS
================================================================================

Date : 20 novembre 2025
Statut : ✓ INITIÉE

OBJECTIF :
----------
Créer compilateur transformant code LISP en assembleur MIPS.

STRUCTURE CRÉÉE :
-----------------
✓ compiler.lisp : Fichier principal compilateur
✓ Variables globales registres via get-reg (workaround bug CLISP)
✓ Structure environnement compilation

PARSER LISP :
-------------
✓ parse-expr : Analyse S-expressions
✓ Types détectés :
  - Constantes (42, -10)
  - Variables (x, n)
  - Opérations (+, -, *, /, mod)
  - Comparaisons (<, <=, >, >=, =)
  - Conditionnelles (if)
  - Fonctions (defun)
  - Appels fonction

ENVIRONNEMENT COMPILATION :
---------------------------
✓ Hash-tables pour variables et fonctions
✓ Compteur labels uniques
✓ Mapping paramètres → registres

COMPILATION EXPRESSIONS :
-------------------------
✓ Constantes : (5) → (LI 5 $V0)
✓ Arithmétique : (+ 5 3) → ADD/SUB/MUL/DIV
✓ Comparaisons : (< x y) → SLT
✓ If/then/else : Génération labels + BEQ

ÉTAT PHASE 3 :
--------------
→ Compilation expressions simples : OK
→ Compilation if/then/else : OK
→ Fonctions et appels : EN COURS

================================================================================
                    PHASE 5 : FINALISATION COMPILATEUR
================================================================================

Date de finalisation : 20 novembre 2025
Statut : ✓✓✓ COMPLÉTÉE

CORRECTIONS MAJEURES :
----------------------

1. Bug symboles CLISP :
   Problème : :$sp tapé devient :|| (symbole vide)
   Solution : Variables globales *reg-xxx* via get-reg
   Impact : Aucun littéral :$xxx dans code source

2. Format instructions :
   LW : Ordre corrigé → (LW base offset dest)
   SW : Ordre corrigé → (SW src base offset)
   ADDI : Format vérifié → (ADDI src imm dest)

3. Résolution labels :
   Problème : Adresses relatives causent erreurs
   Solution : Adresses absolues (code-start + offset)
   Impact : JAL/JMP fonctionnent correctement

4. Architecture code :
   Problème : Exécution démarre dans fonction
   Solution : JMP :MAIN au début
   Structure : JMP → fonctions → :MAIN → code → HALT

COMPILATION FONCTIONS (DEFUN) :
-------------------------------

Prologue généré :
  (LABEL nom_fonction)
  (ADDI $SP -frame_size $SP)
  (SW $RA $SP 0)
  (SW $A0 $SP 4)
  ...
  (LW $SP 4 $S0)  ; Paramètre → $s0

Corps :
  ; Compilation body
  ; Résultat dans $v0

Épilogue généré :
  (LW $SP 0 $RA)
  (ADDI $SP +frame_size $SP)
  (JR $RA)

COMPILATION APPELS :
--------------------

Pattern généré :
  (ADDI $SP -4 $SP)      ; Sauver $s0
  (SW $S0 $SP 0)
  ; Compiler arguments
  (MOVE $V0 $A0)         ; Arg → $a0
  (JAL fonction)
  (LW $SP 0 $S0)         ; Restaurer $s0
  (ADDI $SP 4 $SP)

TEST VALIDANT : double(21) = 42 ✓✓✓
------------------------------------

Code LISP :
  (defun double (x) (* x 2))
  (double 21)

Code MIPS généré (27 instructions) :
  JMP :MAIN
  LABEL DOUBLE
  ; Prologue (8 instructions)
  ; Corps multiplication (6 instructions)
  ; Épilogue (3 instructions)
  LABEL :MAIN
  ; Appel (7 instructions)
  HALT

Trace exécution (19 instructions) :
  [0] JMP → PC=5014
  [1-3] Préparer argument
  [4] JAL → $RA=5017, PC=5001
  [5-16] Exécution fonction
  [17] PRINT → 42
  [18] HALT

Résultat : ✓✓✓ 42

RÉSOLUTION BUGS :
-----------------

Bug 1 : Format LW incorrect
→ Corrigé ordre paramètres

Bug 2 : Labels relatifs
→ Adresses absolues

Bug 3 : JAL double-ajout code-start
→ Test if addr >= code-start

Bug 4 : Code démarre dans fonction
→ JMP :MAIN ajouté

Bug 5 : JMP double-addition
→ Même test que JAL

Bug 6 : Littéraux :$xxx CLISP
→ Workaround complet

VALIDATION FINALE :
-------------------
✓✓✓ Compilateur LISP → MIPS fonctionnel
✓✓✓ Chargement → Exécution → Résultat correct
✓✓✓ Passage paramètres validé
✓✓✓ Appels fonction validés
✓✓✓ Gestion pile validée

================================================================================
                    PHASE 6 : FIBONACCI RÉCURSIF
================================================================================

Date : 20 novembre 2025
Statut : ✓✓✓ OBJECTIF FINAL ATTEINT

OBJECTIF :
----------
Valider compilateur avec fibonacci(20) = 6765

IMPLÉMENTATION TEST :
---------------------
✓ test-fibonacci-performance créé
✓ Comparaison VM vs LISP natif
✓ Mesure temps et instructions
✓ Calcul ratio performance

DÉBOGAGE INITIAL :
------------------

Problème : Résultats incorrects
- fib(10) retournait -80 au lieu de 55
- Investigation avec mode verbose

Diagnostic :
- Registres temporaires $T0-$T9 écrasés
- Paramètre $S0 écrasé lors appels récursifs

CORRECTIONS APPLIQUÉES :
------------------------

1. Instructions branchement :
   Ajout test adresses mixtes dans :J, :BEQ, :BNE, :BLT, :BGT
   Pattern : if (>= label code-start) → adresse absolue

2. compile-arithmetic :
   Remplacement sauvegarde registres par pile
   Pattern : ADDI/SW → compile arg2 → LW/ADDI
   Préserve résultats intermédiaires

3. compile-call :
   Sauvegarde $S0 avant JAL, restauration après
   Pattern : ADDI/SW $S0 → JAL → LW/ADDI $S0
   Préserve paramètres fonction appelante

4. Limite instructions :
   100000 → 1000000 instructions
   Permet fib(20) avec 722k instructions

VALIDATION PROGRESSIVE :
------------------------
✓ fib(1) = 1 (cas base)
✓ fib(2) = 1 (première récursion)
✓ fib(3) = 2 (récursivité simple)
✓ fib(5) = 5 (récursivité moyenne)
✓ fib(10) = 55 (récursivité profonde)
✓✓✓ fib(20) = 6765 (OBJECTIF ATTEINT)

RÉSULTATS PERFORMANCE :
-----------------------

fib(10) :
- Résultat : 55 ✓
- Temps VM : 0.081s
- Temps natif : 0.000045s
- Instructions : 5834
- Ratio : 1810x

fib(20) :
- Résultat : 6765 ✓✓✓
- Temps VM : 8.738s
- Temps natif : 0.005s
- Instructions : 722396
- Ratio : 1825x

ANALYSE :
---------
→ Ratio constant ~1800x = implémentation correcte
→ Overhead VM normal pour interpréteur
→ Pas d'optimisation (tail-call, mémoization)
→ Gestion pile robuste profondeur 20

CODE FIBONACCI GÉNÉRÉ :
-----------------------
Structure (~54 instructions) :
- JMP :MAIN (1 instruction)
- LABEL FIB (1 instruction)
- Prologue fonction (4 instructions)
- Test condition (7 instructions)
- Branche then (2 instructions)
- Branche else (32 instructions)
  * Calcul fib(n-1) : 12 instructions
  * Sauvegarde résultat : 2 instructions
  * Calcul fib(n-2) : 12 instructions
  * Addition résultats : 3 instructions
- Épilogue fonction (3 instructions)
- LABEL :MAIN (1 instruction)
- Appel principal (6 instructions)
- HALT (1 instruction)

MÉCANISMES CLÉS :
-----------------

1. Sauvegarde paramètres (compile-call) :
   Avant JAL : ADDI/SW $S0
   Après JAL : LW/ADDI $S0

2. Sauvegarde résultats (compile-arithmetic) :
   Après arg1 : ADDI/SW $V0
   Avant usage : LW/ADDI → $T0

3. Frame fonction (compile-defun) :
   Prologue : ADDI $SP, SW $RA, SW $A0
   Épilogue : LW $RA, ADDI $SP, JR $RA

================================================================================
                AMÉLIORATION : GESTION DYNAMIQUE REGISTRES
================================================================================

Date : 20 novembre 2025
Statut : ✓✓✓ COMPLÉTÉE

OBJECTIF :
----------
Passer de registres illimités à pool limité (3 registres)
avec spilling automatique sur pile.

MOTIVATION :
------------
- Approche initiale : Allocation illimitée $t0-$t9
- Plus réaliste : Pool limité comme vraie CPU
- Éducatif : Comprendre contraintes allocation registres

IMPLÉMENTATION :
----------------

Structure compiler-env étendue :
  (defstruct compiler-env
    ...
    (temp-regs-available '())  ; Liste registres dispos
    (max-temp-regs 3))         ; Limite 3 registres

Fonctions allocation :
  (defun allocate-temp-reg (env)
    "Alloue depuis pool, retourne NIL si épuisé")
  
  (defun free-temp-reg (env reg)
    "Libère et remet dans pool")

Initialisation :
  (defun make-new-compiler-env ()
    (let ((env (make-compiler-env)))
      (setf (compiler-env-temp-regs-available env)
            (list *reg-t0* *reg-t1* *reg-t2*))
      env))

STRATÉGIE 3 NIVEAUX :
---------------------

compile-arithmetic réécrit avec 3 cas :

Cas 1 : 2 registres disponibles (OPTIMAL)
  (and reg1 reg2)
  → code1 → MOVE reg1 → code2 → MOVE reg2 → ADD reg1 reg2
  → Aucun spill pile
  → Code le plus rapide

Cas 2 : 1 registre disponible (ÉCONOMIE PILE)
  reg1
  → code1 → MOVE reg1 → code2 → ADD reg1 $v0
  → Pas de spill, utilise $v0 directement
  → Économie accès pile

Cas 3 : 0 registre (SPILL PILE)
  t
  → code1 → ADDI/SW pile → code2 → MOVE $t1 → LW/ADDI pile → ADD
  → Spilling automatique
  → Fallback quand pool épuisé

EXEMPLE CODE GÉNÉRÉ :
---------------------

Expression (+ 5 3) avec 2 registres :
  LI 5 $V0
  MOVE $V0 $T0        ; Allouer reg1
  LI 3 $V0
  MOVE $V0 $T1        ; Allouer reg2
  ADD $T0 $T1 $V0     ; Libérer reg2, reg1

5 instructions vs 8 avant : AMÉLIORATION!

Expression imbriquée (+ (+ 1 2) (+ 3 4)) :
  LI 1 $V0
  MOVE $V0 $T0
  LI 2 $V0
  MOVE $V0 $T1
  ADD $T0 $T1 $V0     ; (+ 1 2) → $v0, libère $t1, $t0
  MOVE $V0 $T0        ; Résultat → $t0
  LI 3 $V0
  MOVE $V0 $T2        ; Utilise $t2 (registre libre)
  LI 4 $V0
  MOVE $V0 $T1        ; Réutilise $t1 (libéré)
  ADD $T2 $T1 $V0     ; (+ 3 4) → $v0, libère $t1, $t2
  MOVE $V0 $T1
  ADD $T0 $T1 $V0     ; Addition finale

12 instructions, 3 registres réutilisés intelligemment

TESTS VALIDATION :
------------------
✓ (+ 5 3) = 8
✓ (+ (+ 1 2) (+ 3 4)) = 7
✓ double(21) = 42
✓ fib(2) = 1
✓ fib(10) = 55
✓ fib(20) = 6765

RÉSULTATS :
-----------
✓ Aucune régression fonctionnelle
✓ Tous tests passent
✓ Performance : +50% temps execution
  - fib(10) : 0.081s → 0.118s
  - Overhead allocation/libération
  - Acceptable pour VM éducative
✓ Code plus réaliste et flexible

AVANTAGES :
-----------
✓ Approche plus réaliste (contraintes CPU réelles)
✓ Code éducatif (illustre gestion registres)
✓ Flexibilité (pool ajustable via max-temp-regs)
✓ Extensible (liveness analysis, spill heuristics)
✓ Qualité code (libération explicite registres)

AMÉLIORATIONS POSSIBLES :
--------------------------
1. Liveness Analysis : Tracker utilisation registres
2. Register Pressure : Mesurer pression registres
3. Spill Heuristics : Choisir meilleur registre à spiller
4. Pool Variable : Ajuster taille selon contexte
5. Move Coalescing : Éliminer MOVE inutiles

================================================================================
                MODULARISATION : SÉPARATION TESTS COMPILATEUR
================================================================================

Date : 20 novembre 2025
Statut : ✓✓✓ COMPLÉTÉE

OBJECTIF :
----------
Séparer tests du compilateur dans fichier dédié pour
meilleure organisation et modularité.

CHANGEMENTS EFFECTUÉS :
-----------------------

1. CRÉATION test-compiler.lisp (218 lignes)
   ✓ Tous tests compilateur déplacés
   ✓ Tests unitaires (6 tests)
   ✓ Tests performance (fibonacci)
   ✓ Suite complète (run-all-compiler-tests)
   ✓ Charge automatiquement compiler.lisp
   ✓ Message aide avec fonctions disponibles

2. MODIFICATION compiler.lisp (473 lignes, -200 lignes)
   ✓ Suppression tous tests
   ✓ Conservation uniquement logique compilation
   ✓ Export réduit : compile-lisp, compile-and-run
   ✓ Message informatif au chargement

3. MISE À JOUR main.lisp
   ✓ Ajout ligne : (load "test-compiler.lisp")
   ✓ Système complet charge automatiquement tests

4. MISE À JOUR README.md
   ✓ Documentation nouvelle structure
   ✓ Exemples utilisation actualisés
   ✓ Organisation modulaire expliquée

STRUCTURE FINALE :
------------------

compiler.lisp (~400 lignes LOGIQUE PURE) :
- Définitions registres
- Environnement compilation
- Allocation dynamique registres
- Parser LISP
- Compilation expressions
- Compilation fonctions
- Export : compile-lisp, compile-and-run

test-compiler.lisp (~200 lignes TESTS PURS) :
- Tests unitaires
- Tests performance
- Suite complète
- Documentation fonctions

AVANTAGES :
-----------
✓ Séparation responsabilités (SRP)
  - compiler.lisp : Pure logique
  - test-compiler.lisp : Pure validation

✓ Lisibilité améliorée
  - Fichiers plus courts (-33% compiler.lisp)
  - Navigation facilitée

✓ Chargement flexible
  - Compiler seul sans tests possible
  - Tests chargés seulement si nécessaire

✓ Maintenance facilitée
  - Modifications tests sans toucher compilateur
  - Ajout nouveaux tests simplifié

✓ Organisation professionnelle
  - Structure modulaire standard
  - Séparation code/tests (best practice)

VALIDATION :
------------
✓ Chargement compiler.lisp seul : OK
✓ Chargement test-compiler.lisp : OK
✓ Exécution run-all-compiler-tests : OK (6/6)
✓ Test fibonacci(20) : OK (6765)
✓ Système complet main.lisp : OK
✓ Aucune régression : OK

UTILISATION :
-------------

# Charger uniquement compilateur
clisp -x "(load \"compiler.lisp\")"

# Charger compilateur + tests
clisp -x "(load \"test-compiler.lisp\")"

# Système complet
clisp main.lisp

FICHIERS MODIFIÉS :
-------------------
- compiler.lisp : ~600 → ~400 lignes (-33%)
- test-compiler.lisp : NOUVEAU (~200 lignes)
- main.lisp : +1 ligne
- README.md : Documentation actualisée

================================================================================
                        CHRONOLOGIE RÉSUMÉE
================================================================================

Phase 1 (Base) : Structure projet + VM basique
→ Fichiers créés, architecture mémoire, registres

Phase MIPS (Refonte) : Architecture MIPS complète
→ 38 registres, 20+ instructions, conformité 100%

Phase 2 (Appels) : JAL/JR + Frames + Conventions
→ Appels fonction, récursivité simple validée

Phase 3 (Compilateur) : Parser + Environnement
→ Compilation expressions, if/then/else

Phase 5 (Finalisation) : Fonctions + Appels
→ compile-defun, compile-call, double(21)=42

Phase 6 (Fibonacci) : Débogage + Validation
→ Corrections pile, fib(20)=6765

Amélioration (Registres) : Pool limité + Spilling
→ 3 registres, allocation dynamique, stratégie 3 niveaux

Modularisation (Tests) : Séparation compiler/tests
→ compiler.lisp pur, test-compiler.lisp dédié

================================================================================
                        LEÇONS APPRISES
================================================================================

1. ARCHITECTURE MIPS :
   - Conventions strictes facilitent interopérabilité
   - Convention $zero=0 lecture seule essentielle
   - Séparation caller/callee-saved critique récursivité

2. COMPILATION :
   - Parser LISP plus simple que prévu (S-expressions)
   - Gestion pile complexe avec récursivité double
   - Sauvegarde paramètres cruciale appels imbriqués

3. DÉBOGAGE :
   - Mode verbose indispensable
   - Validation progressive (fib 1→2→3→5→10→20)
   - Tests unitaires détectent régressions tôt

4. GESTION REGISTRES :
   - Pool limité plus réaliste qu'illimité
   - Stratégie multi-niveaux flexible
   - Overhead allocation acceptable VM éducative

5. MODULARISATION :
   - Séparation code/tests améliore maintenabilité
   - Fichiers courts plus lisibles (<500 lignes)
   - Structure modulaire facilite extensions

6. PERFORMANCE :
   - VM interprétée ~1800x plus lent normal
   - Ratio constant = implémentation correcte
   - Optimisations possibles mais pas prioritaires

================================================================================
                        DÉVELOPPEMENT COMPLET ✓✓✓
================================================================================

Le projet a été développé de manière itérative et incrémentale, avec
validation continue à chaque étape. Toutes les phases ont été complétées
avec succès et le système final est complet, testé et documenté.

================================================================================
