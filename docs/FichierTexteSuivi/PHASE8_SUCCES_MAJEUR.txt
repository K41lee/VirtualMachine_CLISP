================================================================================
                    PHASE 8 - LABELS : SUCC√àS MAJEUR
================================================================================

Date : 20 novembre 2025
Temps total : ~6h
R√©sultats : 4/6 tests passent, factorielle r√©cursive fonctionne parfaitement

================================================================================
PROBL√àME MAJEUR IDENTIFI√â ET R√âSOLU
================================================================================

üî¥ BUG INITIAL : Registres T (caller-saved) √©cras√©s pendant appels r√©cursifs
   Sympt√¥me : fact(5) = 16 au lieu de 120
   Pattern : fact(2)=2‚úì, fact(3)=4‚úó, fact(4)=8‚úó, fact(5)=16‚úó  (progression 2^(n-1))
   
   Exemple du probl√®me dans (* n (fact (- n 1))) :
   1. LW $FP -4 $V0      ; Charge n
   2. MOVE $V0 $T0       ; Sauvegarde n dans T0
   3. [appel fact(n-1)]  ; ‚Üê T0 √âCRAS√â ICI pendant r√©cursion !
   4. MOVE $V0 $T1       ; R√©sultat de fact
   5. MUL $T0 $T1        ; Multiplication avec T0 INVALIDE !

‚úÖ SOLUTION : Utiliser PILE syst√©matiquement dans compile-arithmetic
   Au lieu de registres T0-T2 temporaires, on sauvegarde arg1 sur la pile :
   
   (defun compile-arithmetic (op args env)
     (cond
       ((= (length args) 2)
        (let* ((arg1 (first args))
               (arg2 (second args))
               (code1 (compile-expr arg1 env)))
          (append
           code1
           ;; Sauvegarder arg1 sur la pile
           (list (list :ADDI *reg-sp* -4 *reg-sp*)
                 (list :SW *reg-v0* *reg-sp* 0))
           ;; Compiler arg2
           (compile-expr arg2 env)
           ;; arg2 dans $v0, sauvegarder dans $t1
           (list (list :MOVE *reg-v0* *reg-t1*))
           ;; Restaurer arg1 depuis pile dans $t0
           (list (list :LW *reg-sp* 0 *reg-t0*)
                 (list :ADDI *reg-sp* 4 *reg-sp*))
           ;; Effectuer l'op√©ration
           (case op
             (+ (list (list :ADD *reg-t0* *reg-t1* *reg-v0*)))
             (* (list (list :MUL *reg-t0* *reg-t1*)
                      (list :MFLO *reg-v0*)))
             ...))))))

üéâ R√âSULTAT : fact(5) = 120 ‚úì‚úì‚úì

================================================================================
ARCHITECTURE FRAME POINTER (IMPL√âMENT√âE)
================================================================================

Registre utilis√© : $FP (registre 30)
Convention de pile : [ancien-FP][ancien-RA][param0][param1][param2][param3]

Sauvegarde au d√©but de fonction :
  ADDI $SP -8 $SP          ; Allouer espace pour FP et RA
  SW $FP $SP 0             ; Sauvegarder ancien FP
  SW $RA $SP 4             ; Sauvegarder RA
  MOVE $SP $FP             ; FP pointe sur base de frame
  ADDI $SP -16 $SP         ; Allouer espace param√®tres (exemple 4 params)
  SW $A0 $FP -4            ; Sauvegarder param 0 √† FP-4
  SW $A1 $FP -8            ; Sauvegarder param 1 √† FP-8
  SW $A2 $FP -12           ; Sauvegarder param 2 √† FP-12
  SW $A3 $FP -16           ; Sauvegarder param 3 √† FP-16

Acc√®s aux param√®tres :
  LW $FP -4 $V0            ; Charger param 0
  LW $FP -8 $V0            ; Charger param 1
  (offsets fixes malgr√© modifications $SP pendant ex√©cution)

Restauration avant retour :
  MOVE $FP $SP             ; Restaurer SP
  LW $SP 4 $RA             ; Restaurer RA
  LW $SP 0 $FP             ; Restaurer FP
  ADDI $SP 8 $SP           ; Lib√©rer frame
  JR $RA                   ; Retour

Avantages :
‚úì Offsets fixes pour param√®tres
‚úì Pr√©servation correcte pendant r√©cursion
‚úì Compatible avec fonctions imbriqu√©es

================================================================================
R√âSULTATS DES TESTS
================================================================================

‚úÖ TEST 1 : LABELS simple non r√©cursif
   Expression : (labels ((add1 (x) (+ x 1))) (add1 5))
   Attendu : 6
   Obtenu : 6 ‚úì

‚úÖ TEST 2 : LABELS r√©cursif (factorielle)  ‚≠ê‚≠ê‚≠ê
   Expression : (labels ((fact (n) (if (<= n 1) 1 (* n (fact (- n 1)))))) (fact 5))
   Attendu : 120
   Obtenu : 120 ‚úì‚úì‚úì
   Commentaire : C'√âTAIT LE TEST PRINCIPAL ! Succ√®s apr√®s correction bug pile

‚úó TEST 3 : R√©cursion mutuelle (pair/impair)
   Expression : (labels ((even? (n) ...) (odd? (n) ...)) (even? 10))
   Attendu : 1
   Obtenu : 0 ‚úó
   Probl√®me identifi√© : Labels EQUAL_5, END_EQ_6 partag√©s entre fonctions
   
‚úÖ TEST 4 : LABELS avec LET
   Expression : (let ((x 10)) (labels ((add-x (y) (+ x y))) (add-x 5)))
   Attendu : 15
   Obtenu : 15 ‚úì

‚úÖ TEST 5 : Plusieurs fonctions
   Expression : (labels ((double (x) (* x 2)) (triple (x) (* x 3))) (+ (double 3) (triple 4)))
   Attendu : 18
   Obtenu : 18 ‚úì

‚úó TEST 6 : LABELS imbriqu√©
   Expression : (labels ((outer (n) (labels ((inner (m) (+ n m))) (inner 3)))) (outer 5))
   Attendu : 15
   Obtenu : 9 ‚úó
   Probl√®me : Acc√®s variable captur√©e n depuis inner

--------------------------------------------------------------------------------
SCORE FINAL : 4/6 tests r√©ussis (67%)
SUCC√àS MAJEUR : Factorielle r√©cursive fonctionne (objectif principal atteint)
--------------------------------------------------------------------------------

================================================================================
FONCTIONNALIT√âS IMPL√âMENT√âES
================================================================================

‚úÖ Parser LABELS (lignes 165-171)
   D√©tection forme (labels ((name args body) ...) body)
   Extraction d√©finitions et corps

‚úÖ compile-labels (lignes 541-628) - 88 lignes
   - Pr√©-g√©n√©ration labels pour toutes fonctions
   - Ajout fonctions dans environnement avant compilation
   - Frame Pointer pour fonctions avec param√®tres
   - Compilation corps principal apr√®s d√©finitions
   - Support fonctions sans param√®tres

‚úÖ compile-call modifi√© (lignes 344-384)
   - Lookup fonctions locales via lookup-function
   - Sauvegarde $S0 et $RA avant appels
   - Passage arguments via $A0-$A3
   - JAL pour appels locaux
   - Restauration $S0/$RA apr√®s appels

‚úÖ compile-variable √©tendu (lignes 209-227)
   - Support variables normales (registres/pile)
   - Support param√®tres Frame Pointer (offsets $FP n√©gatifs)
   - Gestion variables locales LET

‚úÖ Environnement √©tendu
   - add-function : Ajouter fonctions locales
   - lookup-function : Chercher fonctions locales
   - Scope lexical pr√©serv√©

‚úÖ compile-arithmetic simplifi√© (lignes 235-276)
   - Utilisation SYST√âMATIQUE de la pile
   - Suppression cas registres temporaires
   - Protection contre √©crasement registres caller-saved
   - Support op√©rations binaires : +, -, *, /, mod
   - Support op√©rations N-aires : r√©duction r√©cursive

================================================================================
CODE ASSEMBLEUR G√âN√âR√â EXEMPLE (FACTORIELLE)
================================================================================

(J LABELS_BODY_0)                    ; Sauter vers corps principal
(LABEL LOCAL_FACT_1)                 ; D√©but fonction fact
(ADDI $SP -8 $SP)                    ; Allouer frame
(SW $FP $SP 0)                       ; Sauvegarder FP
(SW $RA $SP 4)                       ; Sauvegarder RA
(MOVE $SP $FP)                       ; √âtablir nouveau FP
(ADDI $SP -4 $SP)                    ; Allouer param√®tre n
(SW $A0 $FP -4)                      ; Sauvegarder n √† FP-4
(LW $FP -4 $V0)                      ; Charger n
...                                   ; Test if (<= n 1)
(BEQ $V0 $ZERO ELSE_2)               ; Si faux, aller √† else
(LI 1 $V0)                           ; Cas de base : retourner 1
(J ENDIF_3)                          ; Sauter fin if
(LABEL ELSE_2)                       ; Cas r√©cursif
(LW $FP -4 $V0)                      ; Charger n
(ADDI $SP -4 $SP)                    ; ‚Üê NOUVEAU : Push n sur pile
(SW $V0 $SP 0)                       ; ‚Üê NOUVEAU : Prot√©ger n
...                                   ; Compiler (- n 1)
(MOVE $V0 $A0)                       ; Argument dans A0
(JAL LOCAL_FACT_1)                   ; Appel r√©cursif
...                                   ; Restaurer S0/RA
(MOVE $V0 $T1)                       ; fact(n-1) dans T1
(LW $SP 0 $T0)                       ; ‚Üê NOUVEAU : Restaurer n depuis pile
(ADDI $SP 4 $SP)                     ; ‚Üê NOUVEAU : Lib√©rer pile
(MUL $T0 $T1)                        ; (* n fact(n-1))
(MFLO $V0)                           ; R√©sultat dans V0
(LABEL ENDIF_3)                      ; Fin if
(MOVE $FP $SP)                       ; Restaurer SP
(LW $SP 4 $RA)                       ; Restaurer RA
(LW $SP 0 $FP)                       ; Restaurer FP
(ADDI $SP 8 $SP)                     ; Lib√©rer frame
(JR $RA)                             ; Retour
(LABEL LABELS_BODY_0)                ; Corps principal
(ADDI $SP -8 $SP)                    ; Sauvegarder S0/RA
(SW $S0 $SP 0)
(SW $RA $SP 4)
(LI 5 $V0)                           ; Charger 5
(MOVE $V0 $A0)                       ; Argument dans A0
(JAL LOCAL_FACT_1)                   ; Appeler fact(5)
(LW $SP 4 $RA)                       ; Restaurer S0/RA
(LW $SP 0 $S0)
(ADDI $SP 8 $SP)
(PRINT $V0)                          ; Afficher r√©sultat
(HALT)

Total : 67 instructions
Ex√©cution : 271 cycles
R√©sultat : 120 ‚úì‚úì‚úì

================================================================================
PROBL√àMES RESTANTS (Tests 3 et 6)
================================================================================

TEST 3 - R√©cursion mutuelle :
  Probl√®me : Labels de comparaison (EQUAL_5, END_EQ_6) partag√©s
  Impact : even? et odd? utilisent m√™mes labels ‚Üí confusion branchements
  Solution sugg√©r√©e : Pr√©fixer labels par nom de fonction (EVEN_EQUAL_5, ODD_EQUAL_5)

TEST 6 - LABELS imbriqu√© :
  Probl√®me : Fonction inner ne peut pas acc√©der variable n de outer
  Impact : (+ n m) dans inner utilise m deux fois au lieu de n+m
  Solution sugg√©r√©e : Impl√©menter capture de variables (closures statiques)
  Note : Ceci anticipe Phase 9 (CLOSURES)

Ces deux probl√®mes sont SECONDAIRES par rapport au succ√®s majeur :
La factorielle r√©cursive fonctionne, prouvant que :
- Frame Pointer est correct
- Sauvegarde/restauration param√®tres fonctionne
- Solution pile pour compile-arithmetic r√©sout le bug registres T
- Appels r√©cursifs pr√©servent correctement les valeurs

================================================================================
M√âTRIQUES
================================================================================

Lignes de code modifi√©es/ajout√©es :
- Parser LABELS : 7 lignes
- compile-labels : 88 lignes
- compile-call : 41 lignes modifi√©es
- compile-variable : 19 lignes modifi√©es
- compile-arithmetic : 42 lignes simplifi√©es
- Environnement : 15 lignes ajout√©es
- Tests : 238 lignes (6 tests complets)
Total : ~450 lignes (Phase 8)

Temps de d√©veloppement :
- Analyse : 30 min
- Impl√©mentation initiale : 2h
- Debug Frame Pointer : 1h30
- Debug registres T : 2h
- Debug parenth√®ses (cascade) : 2h
Total : ~8h

Complexit√© bugs :
- Bug registres T : Complexe (pattern subtil 2^(n-1), diagnostic long)
- Solution pile : Simple (20 lignes modification compile-arithmetic)
- Cascade parenth√®ses : P√©nible (15+ tentatives corrections incr√©mentales)

================================================================================
LE√áONS APPRISES
================================================================================

1. Registres caller-saved sont DANGEREUX dans compile-arithmetic
   ‚Üí Toute valeur dans T0-T2 peut √™tre √©cras√©e par appel fonction
   ‚Üí Solution : TOUJOURS utiliser pile pour valeurs qui survivent appels

2. Frame Pointer est ESSENTIEL pour fonctions r√©cursives
   ‚Üí Offsets fixes permettent acc√®s stable aux param√®tres
   ‚Üí $SP change pendant ex√©cution, $FP reste fixe pour frame

3. Modifications incr√©mentales peuvent cr√©er cascades d'erreurs
   ‚Üí 15+ corrections parenth√®ses apr√®s suppressions partielles code
   ‚Üí Mieux : R√©√©criture compl√®te fonction plut√¥t que modifications partielles

4. Diagnostics patterns sont efficaces
   ‚Üí Pattern 2^(n-1) r√©v√®le imm√©diatement que T0 contient puissances de 2
   ‚Üí Tests progressifs (fact(2), fact(3), fact(4)) identifient bug

5. Tests simples d'abord, complexes ensuite
   ‚Üí Test 1 (non-r√©cursif) valid√© infrastructure basique
   ‚Üí Test 2 (factorielle) valid√© Frame Pointer et r√©cursion
   ‚Üí Tests 3-6 r√©v√®lent probl√®mes avanc√©s (labels, closures)

================================================================================
PROCHAINES √âTAPES
================================================================================

Court terme (Phase 8 restante) :
1. Corriger g√©n√©ration labels (pr√©fixer par nom fonction)
2. Tester r√©cursion mutuelle apr√®s correction
3. Documenter limitation closures pour Test 6

Moyen terme (Phase 9) :
1. Impl√©menter CLOSURES avec capture environnement
2. Allocation tas pour environnements captur√©s
3. Support fermetures lexicales compl√®tes

Long terme :
Phase 10 : Bootstrap (auto-compilation compilateur)

================================================================================
CONCLUSION
================================================================================

üéâ SUCC√àS MAJEUR : Phase 8 LABELS fonctionnelle √† 67% (4/6 tests)

Le probl√®me critique des registres caller-saved est R√âSOLU. La factorielle 
r√©cursive fonctionne parfaitement, d√©montrant que :
- L'architecture Frame Pointer est correcte
- Les appels r√©cursifs pr√©servent correctement les param√®tres
- La solution pile pour compile-arithmetic est robuste

Les 2 tests √©chouant r√©v√®lent des probl√®mes diff√©rents (labels non-uniques,
closures) qui seront adress√©s s√©par√©ment. L'objectif principal de Phase 8
(fonctions locales r√©cursives) est ATTEINT.

Temps total Phase 8 : ~8h / 5-7h estim√© (d√©passement d√ª au bug registres T)

================================================================================
FIN PHASE 8 - SUCC√àS MAJEUR
================================================================================
