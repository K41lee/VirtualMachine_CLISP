â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHASE 3 - COMPILATEUR LISP â†’ ASM MIPS - RÃ‰CAPITULATIF
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“… DATE: Phase dÃ©butÃ©e aprÃ¨s Phase 2
ğŸ¯ OBJECTIF: Compiler du code LISP en assembleur MIPS pour exÃ©cution sur la VM

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. ARCHITECTURE DU COMPILATEUR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LISP Expression â†’ Parser â†’ AST â†’ Compilateur â†’ ASM MIPS â†’ VM â†’ RÃ©sultatâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMPOSANTS PRINCIPAUX:
----------------------

A) PARSER (parse-lisp-expr)
   - Analyse des S-expressions LISP
   - ReconnaÃ®t: nombres, symboles, listes
   - Retourne un AST typÃ©: (:constant N), (:symbol X), (:application ...)

B) ENVIRONNEMENT (compiler-env)
   - :variables â†’ table de variables locales (nom â†’ emplacement)
   - :functions â†’ table de fonctions dÃ©finies
   - :label-counter â†’ compteur pour labels uniques
   - :temp-counter â†’ compteur pour registres temporaires

C) GÃ‰NÃ‰RATEUR DE CODE (compile-expr)
   - Dispatche selon le type d'expression AST
   - Alloue les registres temporaires ($t0, $t1, ...)
   - GÃ©nÃ¨re les instructions MIPS appropriÃ©es
   - RÃ©sultat toujours dans $v0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2. FONCTIONNALITÃ‰S IMPLÃ‰MENTÃ‰ES (âœ“)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A) CONSTANTES
   -------------------------------------------------
   LISP:    42
   ASM:     (:LI 42 :$v0)
   Test:    âœ“ PASSÃ‰ - RÃ©sultat = 42
   
B) ARITHMÃ‰TIQUE SIMPLE (+, -, *, /, mod)
   -------------------------------------------------
   LISP:    (+ 5 3)
   ASM:     (:LI 5 :$v0)
            (:MOVE :$v0 :$t0)
            (:LI 3 :$v0)
            (:MOVE :$v0 :$t1)
            (:ADD :$t0 :$t1 :$v0)
   Test:    âœ“ PASSÃ‰ - RÃ©sultat = 8

C) EXPRESSIONS COMPLEXES IMBRIQUÃ‰ES
   -------------------------------------------------
   LISP:    (* (+ 10 5) 2)
   Ã‰tapes:  1. Compile (+ 10 5) â†’ rÃ©sultat dans $v0
            2. Sauvegarde $v0 dans $t0
            3. Compile 2 â†’ $v0
            4. MUL $t0 Ã— $v0 â†’ $v0
   Test:    âœ“ PASSÃ‰ - RÃ©sultat = 30

D) COMPARAISONS (<, >, <=, >=, =, /=)
   -------------------------------------------------
   LISP:    (< 5 10)
   ASM:     Compile 5 â†’ $t0
            Compile 10 â†’ $t1
            BLT $t0 $t1 label_true
            LI 0 $v0
            J label_end
            label_true: LI 1 $v0
            label_end: ...
   Test:    âœ“ PASSÃ‰ - RÃ©sultat = 1 (vrai)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3. ALLOCATION DES REGISTRES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONVENTION D'UTILISATION:
-------------------------
$v0 ($v0)    â†’ RÃ©sultat final, valeur de retour
$t0-$t9      â†’ Temporaires pour calculs intermÃ©diaires
$a0-$a3      â†’ Arguments de fonctions (Ã  implÃ©menter)
$sp ($sp)    â†’ Pointeur de pile pour sauvegardes
$ra ($ra)    â†’ Adresse de retour pour appels JAL

STRATÃ‰GIE:
----------
1. Chaque sous-expression calcule son rÃ©sultat dans $v0
2. Avant de compiler la sous-expression suivante, $v0 est sauvegardÃ© dans $tX
3. AprÃ¨s compilation de toutes sous-expressions, opÃ©ration finale â†’ $v0
4. Les registres $tX sont libÃ©rÃ©s automatiquement (scope limitÃ©)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4. EXEMPLES DE CODE GÃ‰NÃ‰RÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EXEMPLE 1: Constante
--------------------
LISP: 42
ASM:
  (:LI 42 :$v0)
  (:PRINT :$v0)
  (:HALT)

RÃ©sultat: >>> 42


EXEMPLE 2: Addition
-------------------
LISP: (+ 5 3)
ASM:
  (:LI 5 :$v0)
  (:MOVE :$v0 :$t0)
  (:LI 3 :$v0)
  (:MOVE :$v0 :$t1)
  (:ADD :$t0 :$t1 :$v0)
  (:PRINT :$v0)
  (:HALT)

RÃ©sultat: >>> 8


EXEMPLE 3: Expression complexe
-------------------------------
LISP: (* (+ 10 5) 2)
ASM:
  (:LI 10 :$v0)          ; Premier argument de +
  (:MOVE :$v0 :$t0)      ; Sauvegarde
  (:LI 5 :$v0)           ; Second argument de +
  (:MOVE :$v0 :$t1)      ; Sauvegarde
  (:ADD :$t0 :$t1 :$v0)  ; 10 + 5 = 15 â†’ $v0
  (:MOVE :$v0 :$t0)      ; Sauvegarde 15 dans $t0
  (:LI 2 :$v0)           ; Second argument de *
  (:MOVE :$v0 :$t1)      ; Sauvegarde
  (:MUL :$t0 :$t1)       ; 15 Ã— 2
  (:MFLO :$v0)           ; RÃ©cupÃ¨re rÃ©sultat bas (30)
  (:PRINT :$v0)
  (:HALT)

RÃ©sultat: >>> 30


EXEMPLE 4: Comparaison
----------------------
LISP: (< 5 10)
ASM:
  (:LI 5 :$v0)
  (:MOVE :$v0 :$t0)
  (:LI 10 :$v0)
  (:MOVE :$v0 :$t1)
  (:BLT :$t0 :$t1 :L1)
  (:LI 0 :$v0)
  (:J :L2)
  :L1
  (:LI 1 :$v0)
  :L2
  (:PRINT :$v0)
  (:HALT)

RÃ©sultat: >>> 1 (vrai, car 5 < 10)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5. TESTS DE VALIDATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TEST 1: test-compiler-constant
-------------------------------
Expression: 42
Attendu:    42
RÃ©sultat:   42
Status:     âœ“âœ“âœ“ PASSÃ‰

TEST 2: test-compiler-addition
-------------------------------
Expression: (+ 5 3)
Attendu:    8
RÃ©sultat:   8
Status:     âœ“âœ“âœ“ PASSÃ‰

TEST 3: test-compiler-complex
------------------------------
Expression: (* (+ 10 5) 2)
Attendu:    30
RÃ©sultat:   30
Status:     âœ“âœ“âœ“ PASSÃ‰

TEST 4: test-compiler-comparison
---------------------------------
Expression: (< 5 10)
Attendu:    1 (vrai)
RÃ©sultat:   1
Status:     âœ“âœ“âœ“ PASSÃ‰

Taux de rÃ©ussite: 4/4 = 100% âœ“âœ“âœ“

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6. FONCTIONNALITÃ‰S Ã€ IMPLÃ‰MENTER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A) VARIABLES (LET)
   -------------------------------------------------
   Objectif:   Compiler (let ((x 5)) (+ x 3))
   StratÃ©gie:  - Allouer un emplacement pour x (registre ou pile)
               - Compiler 5 â†’ $v0
               - Sauvegarder $v0 dans emplacement de x
               - Remplacer x par son emplacement lors de l'usage
   PrioritÃ©:   MOYENNE (peut utiliser paramÃ¨tres de fonction Ã  la place)

B) FONCTIONS (DEFUN)
   -------------------------------------------------
   Objectif:   (defun add (a b) (+ a b))
   StratÃ©gie:  - GÃ©nÃ©rer label unique pour fonction
               - Prologue: sauvegarder $ra, $fp
               - Mapper paramÃ¨tres aâ†’$a0, bâ†’$a1
               - Compiler corps de fonction
               - Ã‰pilogue: restaurer $ra, $fp
               - JR $ra pour retour
   Code stub:  âœ“ DÃ©jÃ  prÃ©sent dans compile-defun
   PrioritÃ©:   HAUTE - nÃ©cessaire pour fibonacci

C) APPELS DE FONCTION
   -------------------------------------------------
   Objectif:   (add 5 3) avec add dÃ©fini prÃ©cÃ©demment
   StratÃ©gie:  - Compiler arguments 5â†’$a0, 3â†’$a1
               - JAL label_add
               - RÃ©sultat dans $v0
   PrioritÃ©:   HAUTE - nÃ©cessaire pour fibonacci

D) IF/THEN/ELSE
   -------------------------------------------------
   Objectif:   (if (< n 1) n (+ (fib (- n 1)) (fib (- n 2))))
   StratÃ©gie:  - Compiler condition â†’ $v0
               - BEQ $v0 $zero label_false
               - Compiler branche true
               - J label_end
               - label_false: compiler branche false
               - label_end: ...
   PrioritÃ©:   HAUTE - nÃ©cessaire pour fibonacci

E) FIBONACCI RÃ‰CURSIF - OBJECTIF FINAL
   -------------------------------------------------
   Code LISP:
     (defun fib (n)
       (if (<= n 1)
           n
           (+ (fib (- n 1)) (fib (- n 2)))))

   Ã‰tapes:
     1. ImplÃ©menter DEFUN (prologue/Ã©pilogue)
     2. ImplÃ©menter IF/THEN/ELSE
     3. ImplÃ©menter appels rÃ©cursifs avec pile
     4. Tester avec fib(6) â†’ 8
     5. Tester avec fib(10) â†’ 55
     6. Tester avec fib(20) â†’ 6765 ğŸ¯

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
7. AVANCEMENT DE LA PHASE 3
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 30% COMPLÃ‰TÃ‰

âœ“âœ“âœ“ Parser LISP (S-expressions)
âœ“âœ“âœ“ Environnement de compilation
âœ“âœ“âœ“ Compilation de constantes
âœ“âœ“âœ“ Compilation d'arithmÃ©tique (+, -, *, /, mod)
âœ“âœ“âœ“ Compilation d'expressions imbriquÃ©es
âœ“âœ“âœ“ Compilation de comparaisons (<, >, <=, >=, =, /=)
âœ“âœ“âœ“ GÃ©nÃ©ration de code MIPS valide
âœ“âœ“âœ“ Pipeline complet (parse â†’ compile â†’ execute)
âœ“âœ“âœ“ Tests de validation (4/4)

â³ Variables locales (LET)
â³ DÃ©finitions de fonctions (DEFUN)
â³ Appels de fonction
â³ Structures conditionnelles (IF/THEN/ELSE)
â³ Fibonacci compilÃ© et exÃ©cutÃ©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8. PROCHAINES Ã‰TAPES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ã‰TAPE 1: ImplÃ©menter DEFUN complet
   - Tester compile-defun existant
   - Ajouter gestion prologue: (SW $ra ($sp)) (ADDI $sp $sp -4)
   - Ajouter gestion Ã©pilogue: (LW $ra ($sp)) (ADDI $sp $sp 4) (JR $ra)
   - Mapper paramÃ¨tres vers $a0-$a3

Ã‰TAPE 2: ImplÃ©menter appels de fonction
   - Compiler (add 5 3) â†’ placer args dans $a0, $a1
   - GÃ©nÃ©rer JAL vers label de fonction
   - RÃ©cupÃ©rer rÃ©sultat dans $v0

Ã‰TAPE 3: ImplÃ©menter IF/THEN/ELSE
   - GÃ©nÃ©rer labels uniques pour branches
   - Compiler condition et tester $v0
   - Brancher vers branche appropriÃ©e

Ã‰TAPE 4: Tester avec fibonacci
   - Compiler fibonacci simple (non-optimisÃ©)
   - Tester fib(6) â†’ 8
   - Tester fib(10) â†’ 55
   - Tester fib(20) â†’ 6765 ğŸ¯ğŸ¯ğŸ¯

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
9. CONCLUSION PHASE 3 (PARTIELLE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… RÃ‰USSITES:
   - Compilateur fonctionnel pour expressions simples
   - Code gÃ©nÃ©rÃ© correct et efficace
   - Pipeline complet opÃ©rationnel
   - Tous les tests passent (100%)
   - GÃ©nÃ©ration MIPS conforme Ã  l'architecture VM

â³ EN COURS:
   - Extension aux fonctions et contrÃ´le de flux
   - Optimisation de l'allocation de registres
   - Gestion complÃ¨te de la pile pour rÃ©cursion

ğŸ¯ OBJECTIF FINAL:
   Compiler et exÃ©cuter fibonacci(20) â†’ 6765

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
