================================================================================
                    RÃ‰CAPITULATIF PHASE 2 - APPELS DE FONCTION MIPS
                            Machine Virtuelle LISP
================================================================================

Date: 20 novembre 2025
Statut: âœ“âœ“âœ“ COMPLÃ‰TÃ‰E Ã€ 100%

================================================================================
                        OBJECTIFS DE LA PHASE 2
================================================================================

OBJECTIF PRINCIPAL:
ImplÃ©menter les instructions JAL et JR pour permettre les appels de fonction
dans l'architecture MIPS, avec gestion correcte des frames et de la rÃ©cursivitÃ©.

OBJECTIFS SECONDAIRES:
- Tester les appels de fonction simples
- Tester les appels imbriquÃ©s
- Tester la rÃ©cursivitÃ©
- Valider les conventions d'appel MIPS

================================================================================
                        RÃ‰ALISATIONS
================================================================================

1. INSTRUCTIONS IMPLÃ‰MENTÃ‰ES
-----------------------------

âœ“ JAL (Jump And Link) - Format J
  Syntaxe: (JAL label)
  Effet: $ra = $pc + 1; $pc = code-start + label
  ImplÃ©mentation: vm.lisp, ligne ~371
  Status: TestÃ© et fonctionnel âœ“

âœ“ JR (Jump Register) - Format R
  Syntaxe: (JR $rs)
  Effet: $pc = $rs
  ImplÃ©mentation: vm.lisp, ligne ~383
  Status: TestÃ© et fonctionnel âœ“

2. TESTS CRÃ‰Ã‰S
--------------

âœ“ test-jal-jr (tests.lisp)
  Description: Test d'appel de fonction simple avec JAL/JR
  Code: Fonction ADD_FUNC qui additionne deux arguments
  RÃ©sultat: 5 + 3 = 8 âœ“

âœ“ test-jal-jr-with-stack (tests.lisp)
  Description: Test avec sauvegarde de registres sur pile
  Code: Fonction qui sauvegarde $s0, utilise, puis restaure
  RÃ©sultat: $s0 prÃ©servÃ© correctement âœ“

âœ“ test-nested-calls (tests.lisp)
  Description: Test d'appels imbriquÃ©s (A appelle B)
  Code: FUNC_A appelle FUNC_B avec sauvegarde de $ra
  RÃ©sultat: 5 + 10 + 2 + 5 = 22 âœ“

3. EXEMPLES CRÃ‰Ã‰S
-----------------

âœ“ example-mips-jal-jr (examples-mips.lisp)
  Description: Exemple simple d'appel de fonction
  Code: Fonction ADD_FUNC(7, 3) = 10
  RÃ©sultat: 10 âœ“

âœ“ example-mips-nested-calls (examples-mips.lisp)
  Description: Appels imbriquÃ©s avec sauvegarde $ra
  Code: Mainâ†’FUNC_Aâ†’FUNC_B
  RÃ©sultat: (5 + 10) * 2 + 3 = 33 âœ“

âœ“ example-mips-countdown-recursive (examples-mips.lisp)
  Description: Countdown rÃ©cursif
  Code: countdown(5) affiche 5, 4, 3, 2, 1, 0
  RÃ©sultat: 5â†’4â†’3â†’2â†’1â†’0 âœ“

âœ“ example-mips-fibonacci-recursive (examples-mips.lisp)
  Description: Fibonacci rÃ©cursif
  Code: fib(6) = fib(5) + fib(4)
  RÃ©sultat: fib(6) = 8 âœ“
  SÃ©quence: 0, 1, 1, 2, 3, 5, 8 âœ“

4. COMPATIBILITÃ‰
----------------

âœ“ Mapping automatique anciens registres â†’ nouveaux
  :R0 â†’ :$t0
  :R1 â†’ :$t1
  :R2 â†’ :$t2
  :MEM â†’ :$t3
  :GT â†’ :$gt
  :LT â†’ :$lt
  :EQ â†’ :$eq
  :PL â†’ :$pc
  :FP â†’ :$fp
  :SP â†’ :$sp
  :HP â†’ :$gp

âœ“ Instructions avec aritÃ© variable
  ADD: accepte 2 ou 3 opÃ©randes
  SUB: accepte 2 ou 3 opÃ©randes
  MUL: accepte 2 opÃ©randes

âœ“ Tous les anciens tests passent toujours âœ“

================================================================================
                        ARCHITECTURE DES APPELS
================================================================================

CONVENTION D'APPEL MIPS IMPLÃ‰MENTÃ‰E:

1. AVANT L'APPEL (Appelant):
   - Placer arguments dans $a0-$a3
   - Sauvegarder $t0-$t9 si nÃ©cessaires aprÃ¨s appel (caller-saved)
   - JAL fonction

2. PROLOGUE (AppelÃ©):
   - PUSH $ra (si appels imbriquÃ©s)
   - PUSH $s0-$s7 (si utilisÃ©s)
   - PUSH $fp (si gestion frame)
   - Allouer espace variables locales

3. CORPS DE LA FONCTION:
   - Utiliser $a0-$a3 pour arguments
   - Utiliser $t0-$t9 pour temporaires
   - Utiliser $s0-$s7 pour variables locales
   - Placer rÃ©sultat dans $v0 ($v1 si nÃ©cessaire)

4. Ã‰PILOGUE (AppelÃ©):
   - POP $fp (si sauvegardÃ©)
   - POP $s0-$s7 (si sauvegardÃ©s)
   - POP $ra (si sauvegardÃ©)
   - JR $ra (retour)

5. APRÃˆS LE RETOUR (Appelant):
   - RÃ©cupÃ©rer rÃ©sultat depuis $v0
   - Continuer l'exÃ©cution

================================================================================
                        TESTS DE VALIDATION
================================================================================

TEST 1: Appel simple
--------------------
Code:
  Main: JAL ADD_FUNC avec $a0=5, $a1=3
  ADD_FUNC: $v0 = $a0 + $a1, JR $ra
RÃ©sultat: $v0 = 8 âœ“

TEST 2: Appel avec sauvegarde pile
-----------------------------------
Code:
  Main: $s0=10, $s1=20, JAL FUNC avec $a0=5
  FUNC: PUSH $s0, utilise $s0, POP $s0, JR $ra
RÃ©sultat: $s0=10, $s1=20, $v0=105 âœ“

TEST 3: Appels imbriquÃ©s
-------------------------
Code:
  Main: JAL FUNC_A avec $a0=5
  FUNC_A: PUSH $ra, $a0+=10, JAL FUNC_B, $v0+=5, POP $ra, JR $ra
  FUNC_B: $v0=$a0+2, JR $ra
RÃ©sultat: $v0 = 22 (5+10+2+5) âœ“

TEST 4: RÃ©cursion simple (countdown)
-------------------------------------
Code:
  countdown(n):
    PRINT n
    if n == 0: return
    countdown(n-1)
RÃ©sultat: 5, 4, 3, 2, 1, 0 âœ“

TEST 5: RÃ©cursion complexe (fibonacci)
---------------------------------------
Code:
  fib(n):
    if n <= 1: return n
    return fib(n-1) + fib(n-2)
Test: fib(6)
RÃ©sultat: 8 âœ“
Arbre d'appels:
              fib(6)=8
            /          \
        fib(5)=5      fib(4)=3
        /     \        /     \
    fib(4)  fib(3)  fib(3) fib(2)
    ...     ...     ...    ...

================================================================================
                        STATISTIQUES
================================================================================

Lignes de code ajoutÃ©es:
  vm.lisp: +30 lignes (JAL, JR, compatibilitÃ©)
  tests.lisp: +60 lignes (3 nouveaux tests)
  examples-mips.lisp: +120 lignes (4 nouveaux exemples)
  asm-ops.lisp: +15 lignes (mapping, validation)
  TOTAL: ~225 lignes

Instructions MIPS implÃ©mentÃ©es:
  Total aprÃ¨s Phase 2: 19 instructions natives MIPS
  - Phase 1: 17 instructions
  - Phase 2: +2 instructions (JAL, JR)

Exemples fonctionnels:
  Total aprÃ¨s Phase 2: 14 exemples
  - Phase 1: 10 exemples
  - Phase 2: +4 exemples

Tests:
  Total aprÃ¨s Phase 2: 17 tests
  - Phase 1: 14 tests
  - Phase 2: +3 tests

Taux de rÃ©ussite des tests: 100% âœ“âœ“âœ“

================================================================================
                        PERFORMANCES
================================================================================

Test de Fibonacci fib(6):

Instructions exÃ©cutÃ©es (approximatif):
  - fib(6) effectue ~25 appels rÃ©cursifs
  - Chaque appel: ~10-15 instructions
  - Total: ~300-400 instructions

Temps d'exÃ©cution:
  - VM: instantanÃ© (< 0.1 seconde)
  - LISP natif: instantanÃ© (< 0.01 seconde)
  - Ratio: ~10x plus lent (acceptable pour projet Ã©ducatif)

Utilisation mÃ©moire:
  - Pile: ~50 cellules utilisÃ©es (profondeur rÃ©cursion)
  - Tas: non utilisÃ© dans cet exemple
  - Code: ~40 instructions

================================================================================
                        PROBLÃˆMES RENCONTRÃ‰S ET SOLUTIONS
================================================================================

PROBLÃˆME 1: Anciens registres non reconnus
-------------------------------------------
SymptÃ´me: Erreur "Registre invalide: R0"
Cause: Les tests utilisaient :R0 au lieu de :$t0
Solution: Ajout d'un mapping automatique dans get-register/set-register
Status: âœ“ RÃ©solu

PROBLÃˆME 2: ADD attend 3 arguments
----------------------------------
SymptÃ´me: "Nombre d'arguments incorrect pour ADD"
Cause: Format MIPS (3 opÃ©randes) vs ancien format (2 opÃ©randes)
Solution: DÃ©tection dynamique du nombre d'arguments dans execute-instruction
Status: âœ“ RÃ©solu

PROBLÃˆME 3: Validation stricte de l'aritÃ©
------------------------------------------
SymptÃ´me: Validation Ã©choue pour instructions compatibilitÃ©
Cause: instruction-arity retourne une seule valeur fixe
Solution: Cas spÃ©ciaux dans validate-instruction pour aritÃ© variable
Status: âœ“ RÃ©solu

================================================================================
                        LEÃ‡ONS APPRISES
================================================================================

1. IMPORTANCE DE LA RÃ‰TROCOMPATIBILITÃ‰
   â†’ Maintenir l'ancien format Ã©vite de tout rÃ©Ã©crire
   â†’ Mapping automatique simplifie la transition

2. GESTION DE LA PILE POUR RÃ‰CURSION
   â†’ Sauvegarde de $ra cruciale pour appels imbriquÃ©s
   â†’ PUSH/POP simplifient grandement le code

3. CONVENTIONS D'APPEL MIPS
   â†’ $a0-$a3 pour arguments trÃ¨s intuitif
   â†’ $v0 pour retour simplifie le code
   â†’ $ra automatique avec JAL/JR

4. TESTS PROGRESSIFS
   â†’ Tester simple avant complexe
   â†’ Countdown avant Fibonacci
   â†’ Validation pas Ã  pas

================================================================================
                        PROCHAINES Ã‰TAPES
================================================================================

PHASE 3: COMPILATEUR LISP â†’ ASM MIPS
-------------------------------------

Maintenant que les appels de fonction fonctionnent, nous pouvons:

1. Parser LISP
   - Lire expressions S-expressions
   - Construire un AST (Abstract Syntax Tree)

2. Compiler expressions simples
   - (+ 5 3) â†’ LI, ADD
   - (- 10 4) â†’ LI, SUB
   - (* 7 6) â†’ LI, MUL, MFLO

3. Compiler fonctions
   - (defun add (a b) (+ a b))
   - GÃ©nÃ©rer prologue/Ã©pilogue automatiquement
   - Utiliser JAL/JR pour appels

4. Compiler rÃ©cursion
   - (defun fib (n) (if (<= n 1) n (+ (fib (- n 1)) (fib (- n 2)))))
   - GÃ©nÃ©rer code rÃ©cursif avec sauvegarde registres

5. Objectif final
   - Compiler fibonacci(20)
   - ExÃ©cuter sur la VM
   - RÃ©sultat attendu: 6765

================================================================================
                        CONCLUSION
================================================================================

âœ“âœ“âœ“ PHASE 2 COMPLÃ‰TÃ‰E AVEC SUCCÃˆS âœ“âœ“âœ“

La Phase 2 est un succÃ¨s total:
- JAL et JR implÃ©mentÃ©s et fonctionnels
- Appels de fonction simples: âœ“
- Appels imbriquÃ©s: âœ“
- RÃ©cursion simple: âœ“
- RÃ©cursion complexe (Fibonacci): âœ“
- Tous les tests passent: 100%
- RÃ©trocompatibilitÃ© maintenue: âœ“
- Documentation Ã  jour: âœ“

La VM est maintenant capable de:
- ExÃ©cuter des fonctions avec paramÃ¨tres
- GÃ©rer les appels rÃ©cursifs
- Respecter les conventions d'appel MIPS
- Sauvegarder/restaurer le contexte correctement

PRÃŠT POUR LA PHASE 3 ! ðŸš€

================================================================================

Version: 1.0
Auteur: K41lee
Date: 20 novembre 2025
