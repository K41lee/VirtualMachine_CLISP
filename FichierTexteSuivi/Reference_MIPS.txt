================================================================================
                RÉFÉRENCE ARCHITECTURE MIPS - MACHINE VIRTUELLE
================================================================================

Version: 2.0 - Architecture MIPS
Date: 20 novembre 2025

================================================================================
                        REGISTRES MIPS
================================================================================

La VM implémente les 32 registres MIPS standards plus des extensions:

REGISTRES GÉNÉRAUX (32 registres MIPS standards)
-------------------------------------------------
$0  ($zero)     Constante 0 (toujours zéro, écriture ignorée)
$1  ($at)       Assembleur temporaire (réservé)
$2  ($v0)       Valeur de retour de fonction (1er registre)
$3  ($v1)       Valeur de retour de fonction (2ème registre)
$4  ($a0)       Argument de fonction 1
$5  ($a1)       Argument de fonction 2
$6  ($a2)       Argument de fonction 3
$7  ($a3)       Argument de fonction 4
$8  ($t0)       Temporaire (caller-saved)
$9  ($t1)       Temporaire (caller-saved)
$10 ($t2)       Temporaire (caller-saved)
$11 ($t3)       Temporaire (caller-saved)
$12 ($t4)       Temporaire (caller-saved)
$13 ($t5)       Temporaire (caller-saved)
$14 ($t6)       Temporaire (caller-saved)
$15 ($t7)       Temporaire (caller-saved)
$16 ($s0)       Sauvegardé (callee-saved)
$17 ($s1)       Sauvegardé (callee-saved)
$18 ($s2)       Sauvegardé (callee-saved)
$19 ($s3)       Sauvegardé (callee-saved)
$20 ($s4)       Sauvegardé (callee-saved)
$21 ($s5)       Sauvegardé (callee-saved)
$22 ($s6)       Sauvegardé (callee-saved)
$23 ($s7)       Sauvegardé (callee-saved)
$24 ($t8)       Temporaire (caller-saved)
$25 ($t9)       Temporaire (caller-saved)
$26 ($k0)       Réservé pour OS/kernel
$27 ($k1)       Réservé pour OS/kernel
$28 ($gp)       Global Pointer (pointeur données globales/tas)
$29 ($sp)       Stack Pointer (pointeur de pile)
$30 ($fp)       Frame Pointer (pointeur de frame)
$31 ($ra)       Return Address (adresse de retour)

REGISTRES SPÉCIAUX
------------------
$pc             Program Counter (pointeur d'instruction)
$hi             High (partie haute pour MUL/DIV)
$lo             Low (partie basse pour MUL/DIV)

FLAGS (extension pour compatibilité)
------------------------------------
$gt             Greater Than (résultat de comparaison)
$lt             Less Than (résultat de comparaison)
$eq             Equal (résultat de comparaison)

================================================================================
                    CONVENTIONS D'APPEL MIPS
================================================================================

PASSAGE D'ARGUMENTS
-------------------
- 4 premiers arguments: $a0, $a1, $a2, $a3
- Arguments suivants: sur la pile

VALEURS DE RETOUR
-----------------
- Résultat entier: $v0
- Résultat double: $v0, $v1

REGISTRES CALLER-SAVED (sauvegardés par l'appelant)
----------------------------------------------------
$t0-$t9, $a0-$a3, $v0-$v1
→ Ces registres peuvent être écrasés par un appel de fonction

REGISTRES CALLEE-SAVED (sauvegardés par l'appelé)
--------------------------------------------------
$s0-$s7, $fp, $sp, $ra
→ Une fonction doit restaurer ces registres avant de retourner

================================================================================
                    INSTRUCTIONS ARITHMÉTIQUES
================================================================================

ADD rd rs rt
------------
Format R (3 registres)
Syntaxe: (ADD $t0 $t1 $t2)
Effet: $t2 = $t0 + $t1
Description: Addition de deux registres
Exemple:
    (:LI 5 :$t0)
    (:LI 3 :$t1)
    (:ADD :$t0 :$t1 :$t2)    ; $t2 = 8

ADDI rt rs imm
--------------
Format I (immediate)
Syntaxe: (ADDI $t0 42 $t1)
Effet: $t1 = $t0 + 42
Description: Addition avec une valeur immédiate
Exemple:
    (:LI 10 :$t0)
    (:ADDI :$t0 5 :$t1)      ; $t1 = 15

SUB rd rs rt
------------
Format R
Syntaxe: (SUB $t0 $t1 $t2)
Effet: $t2 = $t0 - $t1
Description: Soustraction
Exemple:
    (:LI 10 :$t0)
    (:LI 3 :$t1)
    (:SUB :$t0 :$t1 :$t2)    ; $t2 = 7

MUL rs rt
---------
Format R (simplifié)
Syntaxe: (MUL $t0 $t1)
Effet: $hi:$lo = $t0 * $t1
Description: Multiplication (résultat 64 bits dans $hi:$lo)
Exemple:
    (:LI 7 :$t0)
    (:LI 6 :$t1)
    (:MUL :$t0 :$t1)         ; $lo = 42, $hi = 0
    (:MFLO :$t2)             ; $t2 = 42

DIV rs rt
---------
Format R
Syntaxe: (DIV $t0 $t1)
Effet: $lo = $t0 / $t1, $hi = $t0 % $t1
Description: Division (quotient dans $lo, reste dans $hi)
Exemple:
    (:LI 10 :$t0)
    (:LI 3 :$t1)
    (:DIV :$t0 :$t1)         ; $lo = 3, $hi = 1
    (:MFLO :$t2)             ; $t2 = 3 (quotient)
    (:MFHI :$t3)             ; $t3 = 1 (reste)

MFLO rd
-------
Move From LO
Syntaxe: (MFLO $t0)
Effet: $t0 = $lo
Description: Copie $lo dans un registre

MFHI rd
-------
Move From HI
Syntaxe: (MFHI $t0)
Effet: $t0 = $hi
Description: Copie $hi dans un registre

================================================================================
                    INSTRUCTIONS DE TRANSFERT
================================================================================

LI rt imm
---------
Load Immediate (pseudo-instruction)
Syntaxe: (LI 42 $t0)
Effet: $t0 = 42
Description: Charge une valeur immédiate
Exemple:
    (:LI 100 :$t0)           ; $t0 = 100

MOVE rd rs
----------
Syntaxe: (MOVE $t0 $t1)
Effet: $t1 = $t0
Description: Copie un registre dans un autre
Exemple:
    (:LI 42 :$t0)
    (:MOVE :$t0 :$t1)        ; $t1 = 42

================================================================================
                    INSTRUCTIONS MÉMOIRE
================================================================================

LW rt offset(rs)
----------------
Load Word
Syntaxe: (LW $t0 offset $t1)
Effet: $t1 = MEM[$t0 + offset]
Description: Charge un mot depuis la mémoire
Exemple:
    (:LI 1000 :$t0)          ; Adresse de base
    (:LW :$t0 0 :$t1)        ; $t1 = MEM[1000]
    (:LW :$t0 4 :$t2)        ; $t2 = MEM[1004]

SW rs offset(rt)
----------------
Store Word
Syntaxe: (SW $t0 $t1 offset)
Effet: MEM[$t1 + offset] = $t0
Description: Stocke un mot en mémoire
Exemple:
    (:LI 42 :$t0)            ; Valeur
    (:LI 1000 :$t1)          ; Adresse de base
    (:SW :$t0 :$t1 0)        ; MEM[1000] = 42
    (:SW :$t0 :$t1 4)        ; MEM[1004] = 42

================================================================================
                    INSTRUCTIONS DE BRANCHEMENT
================================================================================

BEQ rs rt label
---------------
Branch if Equal
Syntaxe: (BEQ $t0 $t1 LABEL)
Effet: Si $t0 == $t1, alors PC = LABEL
Description: Branchement si égal
Exemple:
    (:LI 5 :$t0)
    (:LI 5 :$t1)
    (:BEQ :$t0 :$t1 EQUAL)   ; Saute car 5 == 5

BNE rs rt label
---------------
Branch if Not Equal
Syntaxe: (BNE $t0 $t1 LABEL)
Effet: Si $t0 != $t1, alors PC = LABEL
Exemple:
    (:LI 5 :$t0)
    (:LI 10 :$t1)
    (:BNE :$t0 :$t1 NOTEQUAL) ; Saute car 5 != 10

BLT rs rt label
---------------
Branch if Less Than
Syntaxe: (BLT $t0 $t1 LABEL)
Effet: Si $t0 < $t1, alors PC = LABEL
Exemple:
    (:LI 5 :$t0)
    (:LI 10 :$t1)
    (:BLT :$t0 :$t1 LESS)    ; Saute car 5 < 10

BGT rs rt label
---------------
Branch if Greater Than
Syntaxe: (BGT $t0 $t1 LABEL)
Effet: Si $t0 > $t1, alors PC = LABEL
Exemple:
    (:LI 10 :$t0)
    (:LI 5 :$t1)
    (:BGT :$t0 :$t1 GREATER) ; Saute car 10 > 5

J label
-------
Jump (saut inconditionnel)
Syntaxe: (J LABEL)
Effet: PC = LABEL
Description: Saut inconditionnel
Exemple:
    (:J END)                 ; Saute à END

================================================================================
                    INSTRUCTIONS DE COMPARAISON
================================================================================

SLT rd rs rt
------------
Set on Less Than
Syntaxe: (SLT $t0 $t1 $t2)
Effet: $t2 = ($t0 < $t1) ? 1 : 0
Description: Met 1 si $t0 < $t1, sinon 0
Exemple:
    (:LI 5 :$t0)
    (:LI 10 :$t1)
    (:SLT :$t0 :$t1 :$t2)    ; $t2 = 1 (car 5 < 10)

================================================================================
                    EXEMPLES DE PROGRAMMES MIPS
================================================================================

EXEMPLE 1: Addition simple
--------------------------
(:LI 5 :$t0)                 ; $t0 = 5
(:LI 3 :$t1)                 ; $t1 = 3
(:ADD :$t0 :$t1 :$t2)        ; $t2 = 8
(:PRINT :$t2)                ; >>> 8
(:HALT)

EXEMPLE 2: Boucle (1 à 5)
-------------------------
(:LI 1 :$t0)                 ; Compteur = 1
(:LI 5 :$t1)                 ; Limite = 5
(:LABEL LOOP)
(:PRINT :$t0)                ; Affiche compteur
(:ADDI :$t0 1 :$t0)          ; Compteur++
(:BLT :$t0 :$t1 LOOP)        ; Continue si < 5
(:BEQ :$t0 :$t1 LOOP)        ; Une dernière fois si == 5
(:HALT)

EXEMPLE 3: Factorielle (5!)
----------------------------
(:LI 5 :$a0)                 ; n = 5
(:LI 1 :$v0)                 ; result = 1
(:LI 1 :$t0)                 ; constante 1
(:LABEL LOOP)
(:BLT :$a0 :$t0 END)         ; Si n < 1, fin
(:MUL :$v0 :$a0)             ; $lo = result * n
(:MFLO :$v0)                 ; result = $lo
(:SUB :$a0 :$t0 :$a0)        ; n = n - 1
(:J LOOP)
(:LABEL END)
(:PRINT :$v0)                ; >>> 120
(:HALT)

EXEMPLE 4: Tableau en mémoire
------------------------------
(:LI 1000 :$s0)              ; Adresse de base
(:LI 10 :$t0)                ; Valeur 1
(:LI 20 :$t1)                ; Valeur 2
(:SW :$t0 :$s0 0)            ; MEM[1000] = 10
(:SW :$t1 :$s0 4)            ; MEM[1004] = 20
(:LW :$s0 0 :$t2)            ; $t2 = MEM[1000] = 10
(:LW :$s0 4 :$t3)            ; $t3 = MEM[1004] = 20
(:ADD :$t2 :$t3 :$v0)        ; $v0 = 30
(:PRINT :$v0)
(:HALT)

================================================================================
                    DIFFÉRENCES AVEC MIPS RÉEL
================================================================================

SIMPLIFICATIONS
---------------
1. Pas de format binaire: instructions en S-expressions LISP
2. MUL simplifiée: pas de MULT/MULTU séparés
3. Pas de load delayed slot
4. Pas de branch delayed slot
5. SYSCALL simplifié (pas de codes syscall)
6. Pas de coprocesseur (CP0)
7. Pas d'exceptions matérielles

EXTENSIONS
----------
1. PRINT: pour affichage debug (pas dans MIPS standard)
2. HALT: arrêt explicite (pas dans MIPS standard)
3. Flags $gt, $lt, $eq pour compatibilité
4. Instructions compatibilité avec ancien format

COMPATIBILITÉ
-------------
L'architecture supporte deux styles:
- Style MIPS: (ADD $t0 $t1 $t2)
- Style ancien: (:LOADI 5 :R0) pour rétrocompatibilité

================================================================================
                    DISPOSITION MÉMOIRE
================================================================================

Adresses     | Zone              | Utilisation MIPS
-------------|-------------------|----------------------------------
0            | Réservé           | Jamais utilisé
1-20         | Registres         | Zone variables basses
21-2020      | Tas ($gp)         | Données globales/dynamiques
2021-4999    | (espace libre)    | 
5000 ($sp↓)  | Pile              | Stack frames, variables locales
5000-9999    | Code ($pc)        | Instructions du programme

Convention MIPS:
- $sp descend (décrémente) lors des PUSH
- $gp monte (incrémente) lors des allocations
- $fp pointe vers le début de la frame courante
- $ra contient l'adresse de retour

================================================================================
                    FRAME D'APPEL (À IMPLÉMENTER)
================================================================================

Structure typique d'une frame:
------------------------------
$fp → | Arguments overflow |  ← Ancienne $sp
      | Adresse retour ($ra)|
      | Ancien $fp         |
      | Registres $s0-$s7  |  ← Sauvegarde
      | Variables locales  |
$sp → | Espace temporaire  |  ← Nouvelle $sp

Convention:
1. Appelant place arguments > 4 sur la pile
2. JAL sauvegarde $pc dans $ra
3. Appelé sauvegarde $ra et $fp
4. Appelé alloue espace pour locales
5. À la fin, appelé restaure et JR $ra

================================================================================
