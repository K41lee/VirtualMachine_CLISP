================================================================================
                    DOCUMENTATION DU JEU D'INSTRUCTIONS
                    MACHINE VIRTUELLE - ARCHITECTURE MIPS
================================================================================

Version: 2.0 - Architecture MIPS
Date: 20 novembre 2025

================================================================================
                        FORMAT GÉNÉRAL
================================================================================

Les instructions suivent le format MIPS en S-expressions LISP:
    (OPCODE operand1 operand2 operand3)

Les opérandes peuvent être:
    - Des registres MIPS : :$t0, :$t1, :$a0, :$v0, :$sp, etc.
    - Des valeurs immédiates : nombres entiers
    - Des labels : symboles pour les sauts

Formats d'instructions MIPS:
    Format R (Register): 3 registres - (ADD $rs $rt $rd)
    Format I (Immediate): registre + immédiat - (ADDI $rs imm $rt)
    Format J (Jump): saut - (J label)

================================================================================
                REGISTRES MIPS (32 REGISTRES STANDARDS)
================================================================================

REGISTRES GÉNÉRAUX MIPS:
-------------------------

$0  (:$zero)    Constante 0 (TOUJOURS zéro, écriture ignorée)
$1  (:$at)      Assembleur Temporaire (réservé assembleur)

VALEURS DE RETOUR:
$2  (:$v0)      Valeur de retour de fonction (principale)
$3  (:$v1)      Valeur de retour de fonction (secondaire)

ARGUMENTS DE FONCTION (4 premiers):
$4  (:$a0)      Argument 1
$5  (:$a1)      Argument 2
$6  (:$a2)      Argument 3
$7  (:$a3)      Argument 4

TEMPORAIRES (non sauvegardés / caller-saved):
$8  (:$t0)      Temporaire 0
$9  (:$t1)      Temporaire 1
$10 (:$t2)      Temporaire 2
$11 (:$t3)      Temporaire 3
$12 (:$t4)      Temporaire 4
$13 (:$t5)      Temporaire 5
$14 (:$t6)      Temporaire 6
$15 (:$t7)      Temporaire 7

SAUVEGARDÉS (doivent être préservés / callee-saved):
$16 (:$s0)      Sauvegardé 0
$17 (:$s1)      Sauvegardé 1
$18 (:$s2)      Sauvegardé 2
$19 (:$s3)      Sauvegardé 3
$20 (:$s4)      Sauvegardé 4
$21 (:$s5)      Sauvegardé 5
$22 (:$s6)      Sauvegardé 6
$23 (:$s7)      Sauvegardé 7

TEMPORAIRES ADDITIONNELS:
$24 (:$t8)      Temporaire 8
$25 (:$t9)      Temporaire 9

RÉSERVÉS SYSTÈME:
$26 (:$k0)      Réservé pour OS/Kernel
$27 (:$k1)      Réservé pour OS/Kernel

POINTEURS SPÉCIAUX:
$28 (:$gp)      Global Pointer (données globales/tas)
$29 (:$sp)      Stack Pointer (pointeur de pile)
$30 (:$fp)      Frame Pointer (base de la frame courante)
$31 (:$ra)      Return Address (adresse de retour)

REGISTRES SPÉCIAUX VM:
----------------------
:$pc            Program Counter (pointeur d'instruction)
:$hi            High (partie haute multiplication/division)
:$lo            Low (partie basse multiplication/division)

FLAGS (extension pour compatibilité):
--------------------------------------
:$gt            Greater Than (résultat de comparaison >)
:$lt            Less Than (résultat de comparaison <)
:$eq            Equal (résultat de comparaison =)

================================================================================
            INSTRUCTIONS ARITHMÉTIQUES (FORMAT MIPS)
================================================================================

ADD $rs $rt $rd
---------------
Type: Format R (3 registres)
Description: Addition de deux registres
Syntaxe: (ADD :$t0 :$t1 :$t2)
Effet: $t2 = $t0 + $t1
Conforme MIPS: ✓
Exemple:
    (:LI 5 :$t0)           ; $t0 = 5
    (:LI 3 :$t1)           ; $t1 = 3
    (:ADD :$t0 :$t1 :$t2)  ; $t2 = 5 + 3 = 8

ADDI $rs imm $rt
----------------
Type: Format I (immediate)
Description: Addition avec une valeur immédiate
Syntaxe: (ADDI :$t0 42 :$t1)
Effet: $t1 = $t0 + 42
Conforme MIPS: ✓
Exemple:
    (:LI 10 :$t0)          ; $t0 = 10
    (:ADDI :$t0 5 :$t1)    ; $t1 = 10 + 5 = 15

SUB $rs $rt $rd
---------------
Type: Format R
Description: Soustraction de deux registres
Syntaxe: (SUB :$t0 :$t1 :$t2)
Effet: $t2 = $t0 - $t1
Conforme MIPS: ✓
Exemple:
    (:LI 10 :$t0)          ; $t0 = 10
    (:LI 3 :$t1)           ; $t1 = 3
    (:SUB :$t0 :$t1 :$t2)  ; $t2 = 10 - 3 = 7

MUL $rs $rt
-----------
Type: Format R (simplifié)
Description: Multiplication (résultat 64 bits dans $hi:$lo)
Syntaxe: (MUL :$t0 :$t1)
Effet: $hi:$lo = $t0 * $t1
Conforme MIPS: ✓ (simplifié - MIPS a MULT/MULTU)
Note: Utilisez MFLO/MFHI pour récupérer le résultat
Exemple:
    (:LI 6 :$t0)           ; $t0 = 6
    (:LI 7 :$t1)           ; $t1 = 7
    (:MUL :$t0 :$t1)       ; $lo = 42, $hi = 0
    (:MFLO :$t2)           ; $t2 = $lo = 42

DIV $rs $rt
-----------
Type: Format R
Description: Division entière
Syntaxe: (DIV :$t0 :$t1)
Effet: $lo = $t0 / $t1, $hi = $t0 % $t1
Conforme MIPS: ✓
Erreur: Division par zéro si $t1 = 0
Exemple:
    (:LI 10 :$t0)          ; $t0 = 10
    (:LI 3 :$t1)           ; $t1 = 3
    (:DIV :$t0 :$t1)       ; $lo = 3, $hi = 1
    (:MFLO :$t2)           ; $t2 = quotient = 3
    (:MFHI :$t3)           ; $t3 = reste = 1

MFLO $rd
--------
Type: Format R
Description: Move From LO - Copie $lo dans un registre
Syntaxe: (MFLO :$t0)
Effet: $t0 = $lo
Conforme MIPS: ✓
Utilisation: Récupérer le résultat de MUL ou DIV

MFHI $rd
--------
Type: Format R
Description: Move From HI - Copie $hi dans un registre
Syntaxe: (MFHI :$t0)
Effet: $t0 = $hi
Conforme MIPS: ✓
Utilisation: Récupérer le reste d'une division

================================================================================
            INSTRUCTIONS DE TRANSFERT (FORMAT MIPS)
================================================================================

LI imm $rt
----------
Type: Pseudo-instruction (Load Immediate)
Description: Charge une valeur immédiate dans un registre
Syntaxe: (LI 42 :$t0)
Effet: $t0 = 42
Conforme MIPS: ✓ (pseudo-instruction standard)
Note: En MIPS réel, traduit en LUI + ORI pour grandes valeurs
Exemple:
    (:LI 100 :$t0)      ; $t0 = 100
    (:LI -5 :$t1)       ; $t1 = -5
    (:LI 0 :$t2)        ; $t2 = 0

MOVE $rs $rd
------------
Type: Pseudo-instruction
Description: Copie d'un registre à un autre
Syntaxe: (MOVE :$t0 :$t1)
Effet: $t1 = $t0
Conforme MIPS: ✓ (pseudo-instruction, équivalent à ADD $rs $zero $rd)
Exemple:
    (:LI 42 :$t0)       ; $t0 = 42
    (:MOVE :$t0 :$t1)   ; $t1 = $t0 = 42
    (:MOVE :$zero :$t2) ; $t2 = 0 (copier $zero)

================================================================================
            INSTRUCTIONS MÉMOIRE (FORMAT MIPS)
================================================================================

LW $rs offset $rt
-----------------
Type: Format I (Load Word)
Description: Charge un mot (32 bits) depuis la mémoire
Syntaxe: (LW :$t0 offset :$t1)
Effet: $t1 = MEM[$t0 + offset]
Conforme MIPS: ✓
Format MIPS réel: lw $rt, offset($rs)
Exemple:
    (:LI 1000 :$t0)     ; $t0 = 1000 (adresse de base)
    (:LW :$t0 0 :$t1)   ; $t1 = MEM[1000 + 0] = MEM[1000]
    (:LW :$t0 4 :$t2)   ; $t2 = MEM[1000 + 4] = MEM[1004]
    (:LW :$t0 -4 :$t3)  ; $t3 = MEM[1000 - 4] = MEM[996]

Utilisation typique (accès tableau):
    (:LI 1000 :$s0)     ; Adresse de base du tableau
    (:LI 0 :$t0)        ; Index
    (:LW :$s0 0 :$t1)   ; $t1 = tableau[0]
    (:ADDI :$s0 4 :$s1) ; Avancer de 4 octets
    (:LW :$s1 0 :$t2)   ; $t2 = tableau[1]

SW $rs $rt offset
-----------------
Type: Format I (Store Word)
Description: Stocke un mot (32 bits) en mémoire
Syntaxe: (SW :$t0 :$t1 offset)
Effet: MEM[$t1 + offset] = $t0
Conforme MIPS: ✓
Format MIPS réel: sw $rs, offset($rt)
Exemple:
    (:LI 42 :$t0)       ; $t0 = 42 (valeur à stocker)
    (:LI 1000 :$t1)     ; $t1 = 1000 (adresse de base)
    (:SW :$t0 :$t1 0)   ; MEM[1000 + 0] = 42
    (:SW :$t0 :$t1 4)   ; MEM[1000 + 4] = 42
    (:SW :$t0 :$t1 -4)  ; MEM[1000 - 4] = 42

Utilisation typique (écriture tableau):
    (:LI 1000 :$s0)     ; Adresse de base
    (:LI 10 :$t0)       ; Valeur 1
    (:LI 20 :$t1)       ; Valeur 2
    (:SW :$t0 :$s0 0)   ; tableau[0] = 10
    (:SW :$t1 :$s0 4)   ; tableau[1] = 20

================================================================================
            INSTRUCTIONS DE PILE (COMPATIBILITÉ)
================================================================================

Note: MIPS standard n'a pas d'instructions PUSH/POP dédiées.
      Elles sont implémentées via SW/LW avec $sp.
      Ces instructions sont fournies pour la compatibilité.

PUSH $rs
--------
Description: Empile un registre (décrémente $sp puis stocke)
Syntaxe: (PUSH :$t0)
Effet: $sp = $sp - 4; MEM[$sp] = $t0
Conforme MIPS: Pseudo-instruction (équivalent à: addi $sp, $sp, -4; sw $rs, 0($sp))
Exemple:
    (:LI 42 :$t0)       ; $t0 = 42
    (:PUSH :$t0)        ; Empile 42

Équivalent MIPS standard:
    (:ADDI :$sp -4 :$sp)
    (:SW :$t0 :$sp 0)

POP $rd
-------
Description: Dépile dans un registre (charge puis incrémente $sp)
Syntaxe: (POP :$t0)
Effet: $t0 = MEM[$sp]; $sp = $sp + 4
Conforme MIPS: Pseudo-instruction (équivalent à: lw $rd, 0($sp); addi $sp, $sp, 4)
Exemple:
    (:POP :$t0)         ; Dépile dans $t0

Équivalent MIPS standard:
    (:LW :$sp 0 :$t0)
    (:ADDI :$sp 4 :$sp)

Exemple complet d'utilisation:
    (:LI 10 :$t0)       ; $t0 = 10
    (:LI 20 :$t1)       ; $t1 = 20
    (:PUSH :$t0)        ; Empile 10
    (:PUSH :$t1)        ; Empile 20
    (:POP :$t2)         ; $t2 = 20
    (:POP :$t0)         ; $t0 = 10

================================================================================
            INSTRUCTIONS DE COMPARAISON (FORMAT MIPS)
================================================================================

SLT $rs $rt $rd
---------------
Type: Format R (Set on Less Than)
Description: Met 1 dans $rd si $rs < $rt, sinon 0
Syntaxe: (SLT :$t0 :$t1 :$t2)
Effet: $t2 = ($t0 < $t1) ? 1 : 0
Conforme MIPS: ✓
Exemple:
    (:LI 5 :$t0)           ; $t0 = 5
    (:LI 10 :$t1)          ; $t1 = 10
    (:SLT :$t0 :$t1 :$t2)  ; $t2 = 1 (car 5 < 10)
    (:SLT :$t1 :$t0 :$t3)  ; $t3 = 0 (car 10 >= 5)

Utilisation pour comparaisons:
    ; Pour tester si $t0 < $t1
    (:SLT :$t0 :$t1 :$t2)
    (:BNE :$t2 :$zero LESS)  ; Si $t2 != 0, alors $t0 < $t1
    
    ; Pour tester si $t0 >= $t1
    (:SLT :$t0 :$t1 :$t2)
    (:BEQ :$t2 :$zero GREATEROREQUAL)  ; Si $t2 == 0

CMP $rs $rt (COMPATIBILITÉ)
---------------------------
Description: Compare deux registres (extension non-MIPS)
Syntaxe: (CMP :$t0 :$t1)
Effet: Met à jour les flags $gt, $lt, $eq
    - $eq = 1 si $t0 == $t1, sinon 0
    - $lt = 1 si $t0 < $t1, sinon 0
    - $gt = 1 si $t0 > $t1, sinon 0
Conforme MIPS: ✗ (extension pour compatibilité)
Note: En MIPS pur, utilisez SLT et les branchements BEQ/BNE
Exemple:
    (:LI 10 :$t0)      ; $t0 = 10
    (:LI 5 :$t1)       ; $t1 = 5
    (:CMP :$t0 :$t1)   ; $gt=1, $lt=0, $eq=0 (car 10 > 5)

================================================================================
            INSTRUCTIONS DE SAUT ET BRANCHEMENT (FORMAT MIPS)
================================================================================

J label
-------
Type: Format J (Jump)
Description: Saut inconditionnel
Syntaxe: (J label)
Effet: $pc = adresse du label
Conforme MIPS: ✓
Exemple:
    (:J SKIP)           ; Saute à SKIP
    (:LI 999 :$t0)      ; Cette ligne ne s'exécute pas
    (:LABEL SKIP)       ; Point de saut
    (:LI 42 :$t0)       ; $t0 = 42

BEQ $rs $rt label
-----------------
Type: Format I (Branch if Equal)
Description: Branchement si deux registres sont égaux
Syntaxe: (BEQ :$t0 :$t1 label)
Effet: Si $t0 == $t1, alors $pc = adresse du label
Conforme MIPS: ✓
Exemple:
    (:LI 5 :$t0)
    (:LI 5 :$t1)
    (:BEQ :$t0 :$t1 EQUAL)  ; Saute car 5 == 5
    (:LABEL EQUAL)

Usage avec $zero:
    (:BEQ :$t0 :$zero ISZERO)  ; Saute si $t0 == 0

BNE $rs $rt label
-----------------
Type: Format I (Branch if Not Equal)
Description: Branchement si deux registres sont différents
Syntaxe: (BNE :$t0 :$t1 label)
Effet: Si $t0 != $t1, alors $pc = adresse du label
Conforme MIPS: ✓
Exemple:
    (:LI 5 :$t0)
    (:LI 10 :$t1)
    (:BNE :$t0 :$t1 NOTEQUAL)  ; Saute car 5 != 10
    (:LABEL NOTEQUAL)

BLT $rs $rt label
-----------------
Type: Pseudo-instruction (Branch if Less Than)
Description: Branchement si $rs < $rt
Syntaxe: (BLT :$t0 :$t1 label)
Effet: Si $t0 < $t1, alors $pc = adresse du label
Conforme MIPS: Pseudo-instruction (équivalent à: slt $at, $rs, $rt; bne $at, $zero, label)
Exemple:
    (:LI 5 :$t0)
    (:LI 10 :$t1)
    (:BLT :$t0 :$t1 LESS)  ; Saute car 5 < 10
    (:LABEL LESS)

BGT $rs $rt label
-----------------
Type: Pseudo-instruction (Branch if Greater Than)
Description: Branchement si $rs > $rt
Syntaxe: (BGT :$t0 :$t1 label)
Effet: Si $t0 > $t1, alors $pc = adresse du label
Conforme MIPS: Pseudo-instruction (équivalent à: slt $at, $rt, $rs; bne $at, $zero, label)
Exemple:
    (:LI 10 :$t0)
    (:LI 5 :$t1)
    (:BGT :$t0 :$t1 GREATER)  ; Saute car 10 > 5
    (:LABEL GREATER)

LABEL nom
---------
Description: Définit un point de saut (étiquette)
Syntaxe: (:LABEL NOM)
Effet: Marque un emplacement pour les instructions de branchement
Conforme MIPS: ✓
Note: Les labels sont résolus au chargement et n'occupent pas d'espace
Exemple:
    (:J END)
    (:LI 999 :$t0)
    (:LABEL END)
    (:LI 42 :$t0)

INSTRUCTIONS COMPATIBILITÉ (NON-MIPS STANDARD):
-----------------------------------------------
JMP, JZ, JNZ, JGT, JLT sont maintenus pour rétrocompatibilité
mais l'utilisation des instructions MIPS (J, BEQ, BNE, etc.) est recommandée.

================================================================================
            INSTRUCTIONS DE CONTRÔLE
================================================================================

NOP
---
Type: Format R
Description: Pas d'opération (No Operation)
Syntaxe: (:NOP)
Effet: Aucun effet (incrémente seulement $pc)
Conforme MIPS: ✓ (équivalent à sll $0, $0, 0 en MIPS)
Utilisation: Remplissage, alignement, ou delayed slots
Exemple:
    (:NOP)              ; Ne fait rien
    (:NOP)              ; Ne fait rien

HALT
----
Type: Extension VM
Description: Arrête l'exécution de la VM
Syntaxe: (:HALT)
Effet: VM s'arrête, état = :halted
Conforme MIPS: ✗ (extension - MIPS utilise SYSCALL exit)
Note: Équivalent à un syscall de terminaison en MIPS réel
Exemple:
    (:LI 42 :$v0)
    (:PRINT :$v0)
    (:HALT)             ; Fin du programme

PRINT $rs
---------
Type: Extension VM (Debug)
Description: Affiche un registre sur la sortie standard
Syntaxe: (PRINT :$t0)
Effet: Affiche la valeur de $t0
Conforme MIPS: ✗ (extension debug - MIPS utilise SYSCALL print)
Utilisation: Débogage et visualisation
Exemple:
    (:LI 42 :$t0)
    (:PRINT :$t0)       ; >>> 42
    (:LI 100 :$v0)
    (:PRINT :$v0)       ; >>> 100

================================================================================
            INSTRUCTIONS D'APPEL DE FONCTION (À IMPLÉMENTER)
================================================================================

JAL label
---------
Type: Format J (Jump And Link)
Description: Appelle une fonction (saute et sauvegarde l'adresse de retour)
Syntaxe: (JAL fonction)
Effet: $ra = $pc + 1; $pc = adresse du label
Conforme MIPS: ✓
Statut: TODO - À implémenter dans Phase 2
Usage prévu:
    (:JAL FONCTION)     ; $ra = adresse retour, saute à FONCTION
    ; ... code appelant ...
    (:LABEL FONCTION)
    ; ... code fonction ...
    (:JR :$ra)          ; Retour à l'appelant

JR $rs
------
Type: Format R (Jump Register)
Description: Saute à l'adresse contenue dans un registre
Syntaxe: (JR :$ra)
Effet: $pc = $ra
Conforme MIPS: ✓
Statut: TODO - À implémenter dans Phase 2
Usage typique: retour de fonction
    (:JR :$ra)          ; Retourne à l'appelant

CONVENTION D'APPEL MIPS (À IMPLÉMENTER):
-----------------------------------------
1. Appelant place arguments dans $a0-$a3
2. JAL sauvegarde $pc dans $ra et saute
3. Appelé sauvegarde registres $s0-$s7 si nécessaire
4. Appelé place résultat dans $v0 ($v1 si besoin)
5. JR $ra pour retourner

Exemple complet prévu:
    ; Appelant
    (:LI 5 :$a0)        ; Argument 1
    (:LI 3 :$a1)        ; Argument 2
    (:JAL ADD_FUNC)     ; Appelle fonction
    (:MOVE :$v0 :$t0)   ; Récupère résultat
    (:HALT)
    
    ; Fonction
    (:LABEL ADD_FUNC)
    (:ADD :$a0 :$a1 :$v0)  ; Calcul
    (:JR :$ra)          ; Retour

CALL/RET (COMPATIBILITÉ):
-------------------------
Maintenu pour compatibilité mais JAL/JR est le standard MIPS recommandé.

================================================================================
                EXEMPLES DE PROGRAMMES (FORMAT MIPS)
================================================================================

Exemple 1: Addition simple (5 + 3) - MIPS
------------------------------------------
(:LI 5 :$t0)            ; $t0 = 5
(:LI 3 :$t1)            ; $t1 = 3
(:ADD :$t0 :$t1 :$t2)   ; $t2 = $t0 + $t1 = 8
(:PRINT :$t2)           ; >>> 8
(:HALT)

Exemple 2: Calcul complexe (10 + 5) * 2 - MIPS
-----------------------------------------------
(:LI 10 :$t0)           ; $t0 = 10
(:LI 5 :$t1)            ; $t1 = 5
(:ADD :$t0 :$t1 :$t2)   ; $t2 = 10 + 5 = 15
(:LI 2 :$t3)            ; $t3 = 2
(:MUL :$t2 :$t3)        ; $lo = 15 * 2 = 30
(:MFLO :$v0)            ; $v0 = $lo = 30
(:PRINT :$v0)           ; >>> 30
(:HALT)

Exemple 3: Branchement conditionnel - MIPS
-------------------------------------------
(:LI 15 :$t0)           ; x = 15
(:LI 10 :$t1)           ; seuil = 10
(:BGT :$t0 :$t1 THEN)   ; Si x > 10, aller à THEN
(:LI 200 :$v0)          ; ELSE: $v0 = 200
(:J END)
(:LABEL THEN)
(:LI 100 :$v0)          ; THEN: $v0 = 100
(:LABEL END)
(:PRINT :$v0)           ; >>> 100 (car 15 > 10)
(:HALT)

Exemple 4: Boucle (1 à 5) - MIPS
---------------------------------
(:LI 1 :$t0)            ; Compteur = 1
(:LI 5 :$t1)            ; Limite = 5
(:LABEL LOOP)
(:PRINT :$t0)           ; Affiche compteur
(:ADDI :$t0 1 :$t0)     ; Compteur++
(:BLT :$t0 :$t1 LOOP)   ; Continue si < 5
(:BEQ :$t0 :$t1 LOOP)   ; Une dernière fois si == 5
(:HALT)
; Sortie: 1 2 3 4 5

Exemple 5: Factorielle (5!) - MIPS
-----------------------------------
(:LI 5 :$a0)            ; n = 5 (argument)
(:LI 1 :$v0)            ; result = 1
(:LI 1 :$t0)            ; constante 1
(:LABEL LOOP)
(:BLT :$a0 :$t0 END)    ; Si n < 1, fin
(:MUL :$v0 :$a0)        ; $lo = result * n
(:MFLO :$v0)            ; result = $lo
(:SUB :$a0 :$t0 :$a0)   ; n = n - 1
(:J LOOP)
(:LABEL END)
(:PRINT :$v0)           ; >>> 120
(:HALT)

Exemple 6: Accès mémoire (LW/SW) - MIPS
----------------------------------------
(:LI 1000 :$s0)         ; Adresse de base
(:LI 42 :$t0)           ; Valeur 1
(:LI 100 :$t1)          ; Valeur 2
(:SW :$t0 :$s0 0)       ; MEM[1000] = 42
(:SW :$t1 :$s0 4)       ; MEM[1004] = 100
(:LI 0 :$t2)            ; $t2 = 0
(:LW :$s0 0 :$t2)       ; $t2 = MEM[1000] = 42
(:PRINT :$t2)           ; >>> 42
(:LW :$s0 4 :$t2)       ; $t2 = MEM[1004] = 100
(:PRINT :$t2)           ; >>> 100
(:HALT)

Exemple 7: Utilisation de $zero - MIPS
---------------------------------------
(:LI 42 :$t0)           ; $t0 = 42
(:ADD :$t0 :$zero :$t1) ; $t1 = $t0 + 0 = 42
(:PRINT :$t1)           ; >>> 42
(:MOVE :$zero :$t2)     ; $t2 = 0
(:PRINT :$t2)           ; >>> 0
; Tenter d'écrire dans $zero (ignoré)
(:LI 999 :$zero)        ; Essai (ignoré par la VM)
(:PRINT :$zero)         ; >>> 0 (toujours 0!)
(:HALT)

================================================================================
                CONVENTIONS DE PROGRAMMATION MIPS
================================================================================

1. UTILISATION DES REGISTRES (CONVENTIONS MIPS):

   Temporaires (caller-saved - non préservés):
   - $t0-$t9: Calculs temporaires, peuvent être écrasés par appels
   - $a0-$a3: Arguments de fonction (4 premiers)
   - $v0-$v1: Valeurs de retour
   
   Sauvegardés (callee-saved - doivent être préservés):
   - $s0-$s7: Variables qui doivent survivre aux appels de fonction
   
   Spéciaux:
   - $zero: TOUJOURS 0, ne jamais essayer de modifier
   - $sp: Pointeur de pile, décrémenter avant PUSH
   - $fp: Base de la frame courante
   - $ra: Adresse de retour (pour JAL/JR)
   - $gp: Pointeur global/tas

2. CONVENTION D'APPEL MIPS:
   
   Avant l'appel (appelant):
   - Placer arguments 1-4 dans $a0-$a3
   - Arguments suivants sur la pile
   - Sauvegarder $t0-$t9 si nécessaires après l'appel
   
   Dans la fonction (appelé):
   - Sauvegarder $ra si appels imbriqués
   - Sauvegarder $s0-$s7 si utilisés
   - Placer résultat dans $v0 ($v1 si besoin)
   - Restaurer registres sauvegardés
   - JR $ra pour retourner

3. LABELS:
   - Utiliser MAJUSCULES pour visibilité (LOOP, END, FUNCTION)
   - Noms descriptifs du rôle (EQUAL, GREATER, CONTINUE)
   - Une ligne séparée pour chaque label

4. COMMENTAIRES:
   - Commenter le but de chaque section
   - Indiquer l'état des registres importants
   - Documenter les invariants de boucle
   - Format: (:INSTR) ; Description claire

5. STRUCTURE DES PROGRAMMES MIPS:
   
   main:
       ; Initialisation
       (:LI valeur :$s0)
       
       ; Code principal
       ; ...
       
       (:HALT)
   
   fonction:
       (:LABEL FONCTION)
       ; Prologue (sauvegarde)
       ; Corps de la fonction
       ; Épilogue (restauration)
       (:JR :$ra)

6. BONNES PRATIQUES:
   - Utiliser $zero pour initialiser à 0 (efficace)
   - Préférer ADDI pour incrémenter/décrémenter
   - Utiliser $s0-$s7 pour variables importantes
   - Toujours vérifier débordement pile/tas
================================================================================
                DISPOSITION MÉMOIRE (ARCHITECTURE MIPS)
================================================================================

Adresses     | Zone              | Registre MIPS | Description
-------------|-------------------|---------------|---------------------------
0            | Réservé           | -             | Jamais utilisé (sécurité)
1-20         | Variables basses  | -             | Sauvegarde registres
21-2020      | Tas ($gp→)        | $gp           | Données globales/dynamiques
2021-4999    | (espace libre)    | -             | Zone tampon
5000 ($sp↓)  | Pile              | $sp           | Frames d'appel (descend)
5000-9999    | Code              | $pc           | Instructions du programme

ORGANISATION MIPS:
------------------
- Tas ($gp) MONTE : $gp incrémente lors d'allocations
- Pile ($sp) DESCEND : $sp décrémente lors de PUSH
- Code ($pc) : Instructions chargées en haut de mémoire

FRAME D'APPEL (Convention MIPS):
---------------------------------
$fp →  | Arguments (>4)     |  Arguments additionnels
       | Adresse retour     |  $ra sauvegardé
       | Ancien $fp         |  $fp précédent
       | $s0-$s7 sauvés     |  Registres callee-saved
       | Variables locales  |  Variables de la fonction
$sp →  | Espace temporaire  |  Calculs, appels imbriqués

CROISSANCE MÉMOIRE:
-------------------
Bas ← [Tas→] ←espace libre→ [←Pile] → Haut
     ($gp++)                ($sp--)

ERREURS À ÉVITER:
-----------------
- N'utiliser jamais l'adresse 0
- Vérifier que $gp < $sp (tas ne déborde pas sur pile)
- Stack overflow si $sp ≤ ($gp + marge sécurité)

================================================================================
                CONFORMITÉ AVEC L'ARCHITECTURE MIPS
================================================================================

INSTRUCTIONS 100% CONFORMES MIPS:
----------------------------------
✓ ADD, SUB          (Format R - arithmétique 3 registres)
✓ ADDI              (Format I - arithmétique immédiat)
✓ MUL, DIV          (Utilise $hi:$lo comme MIPS)
✓ MFLO, MFHI        (Move from LO/HI)
✓ LW, SW            (Load/Store Word avec offset)
✓ BEQ, BNE          (Branch if Equal/Not Equal)
✓ J                 (Jump inconditionnel)
✓ SLT               (Set on Less Than)
✓ NOP               (No Operation)

PSEUDO-INSTRUCTIONS MIPS STANDARD:
-----------------------------------
✓ LI                (Load Immediate - équiv. LUI + ORI)
✓ MOVE              (Move - équiv. ADD avec $zero)
✓ BLT, BGT          (Branch Less/Greater - équiv. SLT + BNE)

INSTRUCTIONS À IMPLÉMENTER (Phase 2):
--------------------------------------
□ JAL               (Jump And Link - appel fonction)
□ JR                (Jump Register - retour fonction)

EXTENSIONS NON-MIPS (pour compatibilité/debug):
------------------------------------------------
⚠ PRINT             (Affichage debug - équiv. SYSCALL print)
⚠ HALT              (Arrêt VM - équiv. SYSCALL exit)
⚠ CMP               (Comparaison - utiliser SLT en MIPS pur)
⚠ PUSH/POP          (Pile - utiliser SW/LW avec $sp en MIPS)
⚠ Flags $gt/$lt/$eq (Extensions - MIPS utilise SLT)

COMPATIBILITÉ:
--------------
- Ancien format (LOADI, :R0, etc.) maintenu mais déprécié
- Nouveau code devrait utiliser format MIPS exclusivement
- Transition douce grâce au support dual

RÉSUMÉ CONFORMITÉ:
------------------
Instructions MIPS natives    : 15+
Pseudo-instructions MIPS     : 5
Extensions utiles            : 5
Conformité globale           : ~85% MIPS standard

OBJECTIF:
---------
Fournir une VM éducative conforme MIPS avec extensions pratiques
pour le développement et le débogage, tout en respectant les
conventions et l'architecture MIPS standard.

================================================================================
                        FIN DE LA DOCUMENTATION
================================================================================

Pour plus d'informations sur l'architecture MIPS complète,
consultez Reference_MIPS.txt dans le même dossier.

Version: 2.0 MIPS
Dernière mise à jour: 20 novembre 2025