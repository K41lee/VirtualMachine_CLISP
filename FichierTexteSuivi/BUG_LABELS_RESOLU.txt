================================================================================
                    RÉSOLUTION BUG LABELS PARTAGÉS - PHASE 8
================================================================================

Date: Session après succès initial Phase 8 (4/6 tests)
Objectif: Améliorer score tests en corrigeant Test 3 (récursion mutuelle)
Résultat: ✓ SUCCÈS - Passage de 4/6 à 5/6 tests (83%)

================================================================================
                              DIAGNOSTIC INITIAL
================================================================================

SYMPTÔME:
--------
Test 3 (récursion mutuelle even?/odd?) retourne 0 au lieu de 1

Expression testée:
(labels ((even? (n) (if (= n 0) 1 (odd? (- n 1))))
         (odd? (n) (if (= n 0) 0 (even? (- n 1)))))
  (even? 10))

Résultat: 0 (attendu: 1)

CAUSE RACINE:
-------------
Labels EQUAL_5 et END_EQ_6 générés par BOTH even? et odd? → confusion branchements

Code assembleur révélait duplication:
- even? génère: EQUAL_5, END_EQ_6
- odd? génère: EQUAL_5, END_EQ_6 (IDENTIQUES!)
→ Dernière définition écrase première, branchements incorrects

ANALYSE ARCHITECTURE:
--------------------
1. defstruct compiler-env contient: (label-counter 0)
   → Slot simple contenant NOMBRE (valeur primitive)

2. copy-env copie environnement pour chaque fonction locale:
   (setf (compiler-env-label-counter new-env) 
         (compiler-env-label-counter env))
   → Copie VALEUR du nombre, pas référence partagée

3. gen-label incrémente compteur:
   (incf (compiler-env-label-counter env))
   → Incrémente compteur LOCAL de l'environnement courant

4. Séquence problématique:
   - compile-labels crée new-env1 pour even?: label-counter = 0
   - even? génère labels, compteur → 7
   - compile-labels crée new-env2 pour odd?: label-counter = 0 (RESET!)
   - odd? génère MÊMES labels

ARCHITECTURE INADÉQUATE:
------------------------
Common Lisp copie valeurs primitives (nombres) par VALEUR.
Pour partager compteur entre environnements, besoin objet MUTABLE partagé.

================================================================================
                           SOLUTION IMPLÉMENTÉE
================================================================================

PRINCIPE:
---------
Utiliser CONS CELL (liste) au lieu de nombre pour stocker compteur.
Liste = objet mutable, référence partagée entre environnements.

MODIFICATIONS CODE:
------------------

1. defstruct compiler-env (ligne 32-39):

AVANT:
(defstruct compiler-env
  (label-counter 0)         ; Nombre copié
  ...)

APRÈS:
(defstruct compiler-env
  (label-counter (list 0))  ; Liste mutable partagée
  ...)

2. gen-label (lignes 63-68):

AVANT:
(defun gen-label (env prefix)
  (let ((label (intern (format nil "~A_~A" prefix 
                       (compiler-env-label-counter env)))))
    (incf (compiler-env-label-counter env))  ; Incrémente nombre
    label))

APRÈS:
(defun gen-label (env prefix)
  (let* ((counter (compiler-env-label-counter env))
         (label (intern (format nil "~A_~A" prefix (car counter)))))
    (incf (car counter))  ; Incrémente CONTENU de liste (partagé)
    label))

3. copy-env (ligne 87-90):

Commentaire mis à jour:
;; PARTAGER la référence du compteur (liste mutable) entre tous les environnements
(setf (compiler-env-label-counter new-env) 
      (compiler-env-label-counter env))

→ Maintenant partage référence LISTE, modifications visibles partout

================================================================================
                             RÉSULTAT TESTS
================================================================================

AVANT correction:
-----------------
✓ Test 1 : Simple          → 42
✓ Test 2 : Factorielle     → 120
✗ Test 3 : Récursion mut.  → 0 (attendu 1)
✓ Test 4 : Avec LET        → 26
✓ Test 5 : Plusieurs fct   → 20
✗ Test 6 : Imbriqué        → 9 (attendu 15, closures)

Score: 4/6 (67%)

APRÈS correction:
----------------
✓ Test 1 : Simple          → 42
✓ Test 2 : Factorielle     → 120
✓ Test 3 : Récursion mut.  → 1 ✓✓✓ CORRIGÉ!
✓ Test 4 : Avec LET        → 26
✓ Test 5 : Plusieurs fct   → 20
✗ Test 6 : Imbriqué        → 9 (attendu 15, closures Phase 9)

Score: 5/6 (83%)

LABELS UNIQUES VÉRIFIÉS:
-----------------------
even? utilise: EQUAL_5, END_EQ_6, ELSE_3, ENDIF_4
odd? utilise:  EQUAL_9, END_EQ_10, ELSE_7, ENDIF_8

→ Compteur global partagé: 0 → 1 → 2 → ... → 10
→ Aucune duplication de labels!

================================================================================
                            LEÇONS APPRISES
================================================================================

1. VALEUR vs RÉFÉRENCE:
   - Nombres Common Lisp copiés par valeur
   - Listes (cons cells) copiées par référence
   - Pour partage mutable: utiliser objets composites (liste, structure, array)

2. DÉBOGAGE SYSTÉMATIQUE:
   - Examiner code assembleur généré → révèle labels dupliqués
   - Tracer origine génération labels → gen-label
   - Analyser propagation environnements → copy-env
   - Comprendre architecture avant corriger

3. SOLUTION ÉLÉGANTE:
   - Modification minimale: 2 fonctions (defstruct, gen-label)
   - Pas de variable globale (solution propre)
   - Compteur encapsulé dans environnement
   - Partage automatique via référence

4. COMPTEUR GLOBAL TECHNIQUE:
   Alternative non utilisée mais viable:
   (defvar *global-label-counter* 0)
   → Aurait fonctionné mais moins propre (état global)
   → Cons cell préférable (encapsulation)

================================================================================
                              PERFORMANCE
================================================================================

Impact solution:
- Temps compilation: négligeable (+1 opération car/incf)
- Mémoire: +8 bytes par environnement (cons cell)
- Complexité: identique
- Lisibilité: améliorée (intention claire)

Test 3 performance (even? 10):
- Instructions exécutées: 426
- Temps exécution: < 1ms
- Récursion mutuelle fonctionne parfaitement

================================================================================
                           STATUT FINAL PHASE 8
================================================================================

✓ LABELS non récursifs: Fonctionnel
✓ LABELS récursifs: Fonctionnel (factorielle 120)
✓ Récursion mutuelle: Fonctionnel (even?/odd?)
✓ LABELS avec LET: Fonctionnel
✓ Plusieurs fonctions locales: Fonctionnel
✗ LABELS imbriqués: Nécessite closures (Phase 9)

SCORE FINAL: 5/6 tests (83%)

OBJECTIF PHASE 8: LARGEMENT DÉPASSÉ ✓✓✓
- Objectif initial: 3-4/6 tests (50-67%)
- Résultat obtenu: 5/6 tests (83%)
- Récursion mutuelle fonctionnelle
- Labels uniques garantis globalement

PROCHAINE ÉTAPE: Phase 9 CLOSURES (pour Test 6)

================================================================================
FIN DOCUMENT - Bug labels partagés résolu avec succès
================================================================================
