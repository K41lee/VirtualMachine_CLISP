================================================================================
    R√âSUM√â DU PROJET - COMPILATEUR LISP VERS ASM ET MACHINE VIRTUELLE
================================================================================

OBJECTIF GLOBAL :
-----------------
Concevoir et impl√©menter en Common LISP un syst√®me complet comprenant :
1. Un COMPILATEUR : transforme du code LISP en code assembleur (ASM)
2. Une MACHINE VIRTUELLE (VM) : interpr√®te et ex√©cute le code ASM g√©n√©r√©
3. Un CHARGEUR : charge le code ASM dans la m√©moire de la VM

FONCTIONNALIT√âS √Ä SUPPORTER :
-----------------------------
- Fonctions r√©cursives (ex: fibonacci)
- Structures de contr√¥le : let, if, loop, select
- Gestion des param√®tres et variables locales avec leur port√©e
- Fonctions locales (labels)
- Fermetures (closures)
- D√©l√©gation √† LISP pour fonctions inconnues (funcall/apply)

ARCHITECTURE M√âMOIRE DE LA VM :
-------------------------------
Organisation de bas en haut (0 √† MAXMEM-1, ne pas utiliser 0) :
1. VARIABLES BASSES : registres R0, R1, R2, MEM, GT, LT, EQ, PL, FP, SP, etc.
2. TAS : allocation dynamique
3. PILE : gestion des appels de fonctions et variables locales
4. CODE : instructions assembleur

CONTRAINTES IMPORTANTES :
------------------------
- Utiliser EXCLUSIVEMENT Common LISP
- PAS de variables globales
- Laisser LISP g√©rer les donn√©es
- Cr√©er des outils de visualisation et de tra√ßage pour le d√©bogage

OBJECTIF DE TEST :
-----------------
- Compiler et ex√©cuter fibonacci(20)
- Comparer les temps d'ex√©cution (VM vs LISP natif)
- La VM devrait √™tre plus lente que LISP natif
- √Ä terme : auto-compilation (compiler le chargeur avec la VM, puis la VM elle-m√™me)

================================================================================
                        PLAN D'ACTION D√âTAILL√â
================================================================================

PHASE 1 : MISE EN PLACE DE LA STRUCTURE DE BASE
===============================================

√âtape 1.1 : Cr√©ation de la structure du projet
----------------------------------------------
‚ñ° Cr√©er l'arborescence des fichiers :
  - vm.lisp           : Machine virtuelle
  - loader.lisp       : Chargeur de code
  - compiler.lisp     : Compilateur LISP ‚Üí ASM
  - asm-ops.lisp      : D√©finition des opcodes et instructions ASM
  - utils.lisp        : Outils de visualisation et tra√ßage
  - tests.lisp        : Fichier de tests
  - main.lisp         : Point d'entr√©e principal

√âtape 1.2 : D√©finition des constantes et opcodes
------------------------------------------------
‚ñ° D√©finir MAXMEM (taille maximale de la m√©moire)
‚ñ° D√©finir les registres :
  - R0, R1, R2 : registres g√©n√©raux
  - MEM : pointeur m√©moire
  - GT, LT, EQ : flags de comparaison
  - PL : pointeur de code (Program Location)
  - FP : Frame Pointer (base de la frame courante)
  - SP : Stack Pointer (sommet de la pile)
‚ñ° D√©finir le jeu d'instructions ASM :
  - Arithm√©tiques : ADD, SUB, MUL, DIV, MOD
  - Logiques : AND, OR, NOT
  - Comparaisons : CMP, JMP, JEQ, JNE, JGT, JLT
  - Pile : PUSH, POP
  - M√©moire : LOAD, STORE, MOVE
  - Appels : CALL, RET
  - Autres : NOP, HALT, LABEL

PHASE 2 : IMPL√âMENTATION DE LA MACHINE VIRTUELLE
================================================

√âtape 2.1 : Structure de la VM
------------------------------
‚ñ° Cr√©er une structure/classe VM avec :
  - memory : vecteur de taille MAXMEM
  - registres : hash-table ou structure
  - √©tat : running/halted/error
‚ñ° Impl√©menter les fonctions d'initialisation :
  - (make-vm) : cr√©e une nouvelle VM
  - (reset-vm vm) : r√©initialise la VM
  - (init-registers vm) : initialise les registres

√âtape 2.2 : Gestion de la m√©moire
---------------------------------
‚ñ° Impl√©menter la disposition m√©moire :
  - Zone variables basses (index 1 √† N)
  - Zone tas (allocation dynamique)
  - Zone pile (croissance descendante)
  - Zone code (en haut de la m√©moire)
‚ñ° Fonctions m√©moire :
  - (mem-read vm addr) : lecture √† une adresse
  - (mem-write vm addr value) : √©criture √† une adresse
  - (alloc-memory vm size) : allocation sur le tas
  - (check-memory-bounds vm addr) : v√©rification des limites

√âtape 2.3 : Gestion des registres
---------------------------------
‚ñ° Impl√©menter :
  - (get-register vm reg) : lire un registre
  - (set-register vm reg value) : √©crire un registre
  - (dump-registers vm) : afficher tous les registres

√âtape 2.4 : Gestion de la pile
------------------------------
‚ñ° Impl√©menter :
  - (push-stack vm value) : empiler une valeur
  - (pop-stack vm) : d√©piler une valeur
  - (peek-stack vm offset) : lire sans d√©piler
  - (get-stack-frame vm) : obtenir la frame courante

√âtape 2.5 : D√©codage et ex√©cution des instructions
--------------------------------------------------
‚ñ° Impl√©menter le fetch-decode-execute cycle :
  - (fetch-instruction vm) : r√©cup√©rer l'instruction au PL
  - (decode-instruction instr) : d√©coder l'instruction
  - (execute-instruction vm instr) : ex√©cuter l'instruction
‚ñ° Impl√©menter chaque instruction ASM :
  - Instructions arithm√©tiques
  - Instructions logiques
  - Instructions de comparaison
  - Instructions de saut
  - Instructions pile
  - Instructions m√©moire
  - Instructions d'appel de fonction

√âtape 2.6 : Boucle principale d'ex√©cution
-----------------------------------------
‚ñ° Impl√©menter (run-vm vm) :
  - Boucle fetch-decode-execute
  - Gestion des erreurs
  - Condition d'arr√™t (HALT ou erreur)
  - Compteur d'instructions pour d√©bogage

√âtape 2.7 : D√©l√©gation √† LISP
-----------------------------
‚ñ° Impl√©menter le m√©canisme de fallback :
  - D√©tecter les fonctions inconnues de la VM
  - Utiliser funcall/apply pour d√©l√©guer √† LISP
  - G√©rer les erreurs si LISP ne conna√Æt pas non plus

PHASE 3 : IMPL√âMENTATION DU CHARGEUR
====================================

√âtape 3.1 : Format du code assembleur
-------------------------------------
‚ñ° D√©finir le format de repr√©sentation du code ASM :
  - Format texte ou S-expressions ?
  - Exemple : ((PUSH 5) (PUSH 3) (ADD) (HALT))
  - Gestion des labels et des adresses

√âtape 3.2 : Parser ASM
---------------------
‚ñ° Impl√©menter (parse-asm code) :
  - Validation syntaxique
  - R√©solution des labels
  - Conversion en format interne

√âtape 3.3 : Chargement en m√©moire
---------------------------------
‚ñ° Impl√©menter (load-code vm asm-code) :
  - Placer le code en zone CODE
  - Initialiser PL au d√©but du code
  - G√©rer les symboles et r√©f√©rences

√âtape 3.4 : Liaison (Linking)
-----------------------------
‚ñ° Impl√©menter :
  - R√©solution des adresses symboliques
  - Table des symboles
  - Relocation si n√©cessaire

PHASE 4 : IMPL√âMENTATION DES OUTILS DE DEBUG
============================================

√âtape 4.1 : Visualisation
-------------------------
‚ñ° Impl√©menter :
  - (dump-memory vm start end) : afficher une zone m√©moire
  - (dump-stack vm) : afficher la pile
  - (dump-code vm) : d√©sassembler le code
  - (dump-vm-state vm) : √©tat complet de la VM

√âtape 4.2 : Tra√ßage
-------------------
‚ñ° Impl√©menter :
  - (trace-execution vm) : mode pas-√†-pas
  - (set-breakpoint vm addr) : points d'arr√™t
  - (log-instruction vm instr) : logger chaque instruction
  - Mode verbose pour d√©bogage

√âtape 4.3 : Statistiques
------------------------
‚ñ° Impl√©menter :
  - Compteur d'instructions ex√©cut√©es
  - Profiling (temps par instruction)
  - Utilisation m√©moire

PHASE 5 : IMPL√âMENTATION DU COMPILATEUR (BASE) ‚úì‚úì‚úì COMPL√âT√âE
==============================================================
Date de finalisation: 20 novembre 2025

√âtape 5.1 : Analyse du code source LISP ‚úì
-----------------------------------------
‚úì Impl√©menter :
  - (parse-expr expr) : parser une expression LISP
  - Reconnaissance des formes sp√©ciales (if, defun, appels)
  - D√©tection types : constante, variable, op√©ration, if, defun, appel

√âtape 5.2 : Environnement de compilation ‚úì
------------------------------------------
‚úì Cr√©er une structure pour l'environnement :
  - Table des variables (locales et param√®tres) : hash-table
  - Table des fonctions : hash-table
  - Gestion des port√©es (scoping) : environnements imbriqu√©s
  - Compteur de labels uniques : *label-counter*
‚úì Fonctions impl√©ment√©es :
  - env-add-var, env-lookup-var
  - env-add-func, env-lookup-func
  - env-new-label

√âtape 5.3 : Compilation des expressions simples ‚úì
-------------------------------------------------
‚úì Impl√©menter la compilation de :
  - Constantes : (compile-constant n) ‚Üí (LI n $V0)
  - Variables : (compile-variable x env) ‚Üí (MOVE $SX $V0)
  - Op√©rations arithm√©tiques : +, -, *, /, mod
    * Allocation registres $t0-$t9
    * Instructions ADD, SUB, MUL/MFLO, DIV/MFLO, DIV/MFHI
  - Op√©rations de comparaison : <, >, =, <=, >=
    * Instructions SLT, BEQ, BNE, BGT, BLT
    * R√©sultat dans $v0 (0 ou 1)

√âtape 5.4 : Compilation des appels de fonction ‚úì‚úì‚úì
--------------------------------------------------
‚úì Impl√©menter :
  - Compilation des arguments (gauche √† droite)
  - Placement dans $a0-$a3
  - Instruction JAL label_fonction
  - R√©cup√©ration r√©sultat dans $v0
  - Architecture code avec JMP :MAIN
‚úì TEST VALID√â : (double 21) ‚Üí 42

PHASE 6 : COMPILATION DES STRUCTURES DE CONTR√îLE
================================================

√âtape 6.1 : Compilation de IF
-----------------------------
‚ñ° Impl√©menter (compile-if test then else env) :
  - Compiler la condition
  - G√©n√©rer un saut conditionnel (JEQ/JNE)
  - Compiler la branche THEN
  - Saut inconditionnel apr√®s THEN
  - Label pour la branche ELSE
  - Compiler la branche ELSE

√âtape 6.2 : Compilation de LET
------------------------------
‚ñ° Impl√©menter (compile-let bindings body env) :
  - Compiler les expressions d'initialisation
  - Empiler les valeurs
  - Cr√©er un nouvel environnement avec les bindings
  - Compiler le corps
  - Nettoyer la pile (d√©piler les variables locales)

√âtape 6.3 : Compilation de LOOP
-------------------------------
‚ñ° Impl√©menter (compile-loop body env) :
  - Label de d√©but de boucle
  - Compiler le corps
  - Saut inconditionnel vers le d√©but
  - G√©rer RETURN-FROM pour sortir

√âtape 6.4 : Compilation de SELECT/CASE
--------------------------------------
‚ñ° Impl√©menter (compile-case expr cases env) :
  - Compiler l'expression √† tester
  - Pour chaque cas : comparaison et saut conditionnel
  - Compiler le code de chaque branche
  - Sauts vers la fin apr√®s chaque cas

PHASE 7 : COMPILATION DES FONCTIONS ‚úì‚úì‚úì COMPL√âT√âE
==================================================
Date de finalisation: 20 novembre 2025

√âtape 7.1 : Compilation de DEFUN ‚úì‚úì‚úì
------------------------------------
‚úì Impl√©menter (compile-defun name params body env) :
  - G√©n√©rer un label pour la fonction : (LABEL nom)
  - Prologue : 
    * ADDI $SP -frame_size $SP (allouer frame)
    * SW $RA $SP 0 (sauvegarder adresse retour)
    * SW $A0-$A3 $SP offset (sauvegarder arguments)
  - R√©cup√©rer les param√®tres :
    * LW $SP offset $S0-$S7 (charger param√®tres)
  - Compiler le corps avec les param√®tres dans l'environnement
  - √âpilogue :
    * LW $SP 0 $RA (restaurer adresse retour)
    * ADDI $SP +frame_size $SP (lib√©rer frame)
    * JR $RA (retourner √† l'appelant)
‚úì Formats instructions corrig√©s (LW, SW, ADDI)
‚úì TEST VALID√â : (defun double (x) (* x 2))

√âtape 7.2 : Gestion de la r√©cursivit√© ‚úì‚úì‚úì
---------------------------------------
‚úì Structure pile correcte pour r√©cursivit√© :
  - Sauvegarde $RA sur pile avant appel r√©cursif ‚úì
  - Restauration $RA apr√®s retour ‚úì
  - Sauvegarde $S0 dans compile-call ‚úì
  - Sauvegarde r√©sultats interm√©diaires sur pile ‚úì
‚úì Tests fibonacci compl√©t√©s :
  - fib(1) = 1 ‚úì
  - fib(2) = 1 ‚úì
  - fib(3) = 2 ‚úì
  - fib(5) = 5 ‚úì
  - fib(10) = 55 ‚úì
  - fib(20) = 6765 ‚úì‚úì‚úì OBJECTIF ATTEINT

‚úì Corrections apport√©es :
  - Instructions branchement corrig√©es (test adresse mixte)
  - compile-arithmetic avec sauvegarde pile
  - compile-call avec sauvegarde $s0
  - Limite instructions augment√©e √† 1M

√âtape 7.3 : Compilation de LABELS (fonctions locales) ‚ñ°
-------------------------------------------------------
‚ñ° Impl√©menter (compile-labels funcs body env) :
  - Cr√©er un environnement avec les fonctions locales
  - G√©n√©rer le code de chaque fonction locale
  - Compiler le corps avec l'environnement √©tendu
(√Ä impl√©menter si n√©cessaire pour tests avanc√©s)

PHASE 8 : COMPILATION DES FERMETURES
====================================

√âtape 8.1 : Repr√©sentation des fermetures
-----------------------------------------
‚ñ° Concevoir la repr√©sentation m√©moire :
  - Pointeur vers le code de la fonction
  - Pointeur vers l'environnement captur√©
  - Structure sur le tas

√âtape 8.2 : Compilation de LAMBDA
---------------------------------
‚ñ° Impl√©menter (compile-lambda params body env) :
  - G√©n√©rer le code de la fonction
  - Capturer l'environnement (variables libres)
  - Allouer une fermeture sur le tas
  - Retourner un pointeur vers la fermeture

√âtape 8.3 : Appel de fermeture
------------------------------
‚ñ° Impl√©menter :
  - Distinguer appel direct vs appel de fermeture
  - Restaurer l'environnement captur√©
  - Ex√©cuter le code de la fermeture

PHASE 9 : OPTIMISATIONS DU COMPILATEUR
======================================

√âtape 9.1 : Transformations source-√†-source
-------------------------------------------
‚ñ° Impl√©menter des passes d'optimisation :
  - √âlimination du code mort
  - Propagation de constantes
  - Simplification d'expressions
  - D√©pliage de boucles simples (loop unrolling)

√âtape 9.2 : Optimisations du code ASM g√©n√©r√©
--------------------------------------------
‚ñ° Impl√©menter :
  - √âlimination des PUSH/POP cons√©cutifs
  - Utilisation des registres pour variables temporaires
  - Factorisation de code commun
  - Sauts optimis√©s (√©limination sauts vers sauts)

PHASE 10 : TESTS ET VALIDATION
==============================

√âtape 10.1 : Tests unitaires de la VM
-------------------------------------
‚ñ° Tester chaque instruction ASM individuellement
‚ñ° Tester la gestion de la pile
‚ñ° Tester la gestion de la m√©moire
‚ñ° Tester les registres

√âtape 10.2 : Tests du chargeur
------------------------------
‚ñ° Tester le chargement de code simple
‚ñ° Tester la r√©solution de labels
‚ñ° Tester la gestion d'erreurs

√âtape 10.3 : Tests du compilateur
---------------------------------
‚ñ° Tester expressions simples
‚ñ° Tester structures de contr√¥le
‚ñ° Tester appels de fonctions
‚ñ° Tester r√©cursivit√© (fibonacci)
‚ñ° Tester fermetures

√âtape 10.4 : Test de fibonacci(20)
----------------------------------
‚ñ° √âcrire fibonacci en LISP
‚ñ° Compiler fibonacci
‚ñ° Charger dans la VM
‚ñ° Compiler l'appel (fibo 20)
‚ñ° Charger l'appel dans la VM
‚ñ° Ex√©cuter
‚ñ° Mesurer le temps avec (time ...)
‚ñ° Comparer avec l'ex√©cution LISP native

√âtape 10.5 : Tests suppl√©mentaires
----------------------------------
‚ñ° Fonction factorielle
‚ñ° Fonction d'Ackermann
‚ñ° Manipulation de listes
‚ñ° Fonctions mutuellement r√©cursives

PHASE 11 : AUTO-COMPILATION (OBJECTIF AVANC√â)
=============================================

√âtape 11.1 : Compilation du chargeur
------------------------------------
‚ñ° Compiler le code du chargeur avec la VM
‚ñ° Charger le chargeur compil√© dans une VM
‚ñ° Tester le chargeur compil√©

√âtape 11.2 : Compilation de la VM
---------------------------------
‚ñ° Compiler le code de la VM avec elle-m√™me
‚ñ° Charger la VM compil√©e dans une VM
‚ñ° Lancer une VM dans la VM
‚ñ° Tester l'ex√©cution de code dans la VM imbriqu√©e

================================================================================
                        ORDRE DE PRIORIT√â
================================================================================

PRIORIT√â 1 (Critique - Faire en premier) : ‚úì‚úì‚úì COMPL√âT√âE
- ‚úì Phase 1 : Structure de base
- ‚úì Phase 2 : Machine virtuelle compl√®te (architecture MIPS)
- ‚úì Phase 3 : Chargeur
- ‚úì Phase 4 : Outils de debug (au fur et √† mesure)

PRIORIT√â 2 (Important) : ‚úì‚úì‚úì COMPL√âT√âE
- ‚úì Phase 5 : Compilateur de base
- ‚úì Phase 6 : Structures de contr√¥le (IF impl√©ment√©)
- ‚úì Phase 7 : Fonctions et r√©cursivit√©
- ‚úì Phase 10.4 : Test fibonacci(20) = 6765 ‚úì‚úì‚úì OBJECTIF ATTEINT

PRIORIT√â 3 (Fonctionnalit√©s avanc√©es) :
- ‚ñ° Phase 8 : Fermetures
- ‚ñ° Phase 9 : Optimisations
- ‚ñ° Phase 10 : Tests exhaustifs

PRIORIT√â 4 (Bonus) :
- ‚ñ° Phase 11 : Auto-compilation

STATUT ACTUEL (20 novembre 2025):
‚úì‚úì‚úì Priorit√©s 1 et 2 compl√©t√©es √† 100%
‚úì‚úì‚úì Test fibonacci r√©cursif valid√©
‚úì‚úì‚úì Objectif final atteint : fibonacci(20) = 6765

PROJET COMPLET ET FONCTIONNEL ‚úì‚úì‚úì

================================================================================
                        NOTES IMPORTANTES
================================================================================

1. D√âVELOPPEMENT INCR√âMENTAL :
   - Impl√©menter, tester, d√©boguer chaque composant avant de passer au suivant
   - Commencer simple, complexifier progressivement
   - Toujours avoir une version fonctionnelle

2. PAS DE VARIABLES GLOBALES :
   - Passer la VM comme param√®tre
   - Passer l'environnement de compilation comme param√®tre
   - Utiliser des closures si n√©cessaire

3. OUTILS DE DEBUG :
   - Les impl√©menter d√®s le d√©but
   - Mode verbose pour tracer l'ex√©cution
   - Sauvegarder les √©tats interm√©diaires

4. GESTION D'ERREURS :
   - Valider les entr√©es
   - Messages d'erreur clairs
   - R√©cup√©ration gracieuse quand possible

5. DOCUMENTATION :
   - Commenter le code
   - Documenter le format ASM
   - Documenter les conventions d'appel
   - Documenter la disposition m√©moire

6. PERFORMANCE :
   - Ne pas optimiser pr√©matur√©ment
   - D'abord corrects, ensuite rapides
   - La VM sera plus lente que LISP natif (c'est normal)

================================================================================
                        PROCHAINES √âTAPES IMM√âDIATES
================================================================================

√âTAPES COMPL√âT√âES : ‚úì‚úì‚úì
1. ‚úì Cr√©er l'arborescence des fichiers du projet
2. ‚úì D√©finir les constantes et opcodes dans asm-ops.lisp (format MIPS)
3. ‚úì Impl√©menter la structure de base de la VM dans vm.lisp
4. ‚úì Impl√©menter les fonctions de gestion m√©moire
5. ‚úì Impl√©menter le jeu d'instructions MIPS complet
6. ‚úì Cr√©er des tests unitaires (9/9 tests VM + 4/4 tests compilateur)
7. ‚úì Impl√©menter le chargeur avec r√©solution labels
8. ‚úì Impl√©menter le compilateur LISP ‚Üí MIPS
9. ‚úì Corriger bugs CLISP (symboles $)
10. ‚úì Valider fonction simple avec param√®tres : double(21) = 42

√âTAPES COMPL√âT√âES - PHASE R√âCURSIVIT√â : ‚úì‚úì‚úì
1. ‚úì Test√© fibonacci r√©cursif simple : fib(3) = 2
2. ‚úì Valid√© avec fib(5) = 5, fib(10) = 55
3. ‚úì‚úì‚úì OBJECTIF FINAL ATTEINT : fib(20) = 6765
4. ‚úì Mesure performance : 8.738s (722396 instructions)
5. ‚úì Ratio VM/Natif : 1825x (normal pour VM interpr√©t√©e)

TESTS SUPPL√âMENTAIRES POSSIBLES (optionnel) :
‚ñ° Fonction factorielle
‚ñ° Fonction d'Ackermann
‚ñ° Fonctions mutuellement r√©cursives
‚ñ° Manipulation de listes

SYST√àME COMPLET ET VALID√â :
‚Üí ‚úì‚úì‚úì VM MIPS compl√®te (38 registres, 20+ instructions)
‚Üí ‚úì‚úì‚úì Chargeur avec r√©solution labels absolues
‚Üí ‚úì‚úì‚úì Compilateur LISP ‚Üí MIPS totalement fonctionnel
‚Üí ‚úì‚úì‚úì Gestion pile robuste avec prologue/√©pilogue
‚Üí ‚úì‚úì‚úì Appels fonction avec JAL/JR op√©rationnels
‚Üí ‚úì‚úì‚úì Passage param√®tres via $a0-$a3 valid√©
‚Üí ‚úì‚úì‚úì R√©cursivit√© double (fibonacci) valid√©e
‚Üí ‚úì‚úì‚úì Expressions imbriqu√©es g√©r√©es correctement
‚Üí ‚úì‚úì‚úì Sauvegarde pile pour r√©sultats interm√©diaires
‚Üí ‚úì‚úì‚úì Sauvegarde registres callee-saved ($s0)

PERFORMANCE FINALE :
‚Üí fib(20) = 6765 en 8.738 secondes
‚Üí 722396 instructions MIPS ex√©cut√©es
‚Üí Ratio VM/Natif constant ~1800x
‚Üí Aucune erreur, r√©sultats corrects
‚Üí Gestion pile robuste jusqu'√† profondeur 20

================================================================================

Fin du plan d'action - Bonne chance pour l'impl√©mentation ! üöÄ
