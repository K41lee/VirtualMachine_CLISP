================================================================================
    R√âSUM√â DU PROJET - COMPILATEUR LISP VERS ASM ET MACHINE VIRTUELLE
================================================================================

OBJECTIF GLOBAL :
-----------------
Concevoir et impl√©menter en Common LISP un syst√®me complet comprenant :
1. Un COMPILATEUR : transforme du code LISP en code assembleur (ASM)
2. Une MACHINE VIRTUELLE (VM) : interpr√®te et ex√©cute le code ASM g√©n√©r√©
3. Un CHARGEUR : charge le code ASM dans la m√©moire de la VM

FONCTIONNALIT√âS √Ä SUPPORTER :
-----------------------------
- Fonctions r√©cursives (ex: fibonacci)
- Structures de contr√¥le : let, if, loop, select
- Gestion des param√®tres et variables locales avec leur port√©e
- Fonctions locales (labels)
- Fermetures (closures)
- D√©l√©gation √† LISP pour fonctions inconnues (funcall/apply)

ARCHITECTURE M√âMOIRE DE LA VM :
-------------------------------
Organisation de bas en haut (0 √† MAXMEM-1, ne pas utiliser 0) :
1. VARIABLES BASSES : registres R0, R1, R2, MEM, GT, LT, EQ, PL, FP, SP, etc.
2. TAS : allocation dynamique
3. PILE : gestion des appels de fonctions et variables locales
4. CODE : instructions assembleur

CONTRAINTES IMPORTANTES :
------------------------
- Utiliser EXCLUSIVEMENT Common LISP
- PAS de variables globales
- Laisser LISP g√©rer les donn√©es
- Cr√©er des outils de visualisation et de tra√ßage pour le d√©bogage

OBJECTIF DE TEST :
-----------------
- Compiler et ex√©cuter fibonacci(20)
- Comparer les temps d'ex√©cution (VM vs LISP natif)
- La VM devrait √™tre plus lente que LISP natif
- √Ä terme : auto-compilation (compiler le chargeur avec la VM, puis la VM elle-m√™me)

================================================================================
                        PLAN D'ACTION D√âTAILL√â
================================================================================

PHASE 1 : MISE EN PLACE DE LA STRUCTURE DE BASE
===============================================

√âtape 1.1 : Cr√©ation de la structure du projet
----------------------------------------------
‚ñ° Cr√©er l'arborescence des fichiers :
  - vm.lisp           : Machine virtuelle
  - loader.lisp       : Chargeur de code
  - compiler.lisp     : Compilateur LISP ‚Üí ASM
  - asm-ops.lisp      : D√©finition des opcodes et instructions ASM
  - utils.lisp        : Outils de visualisation et tra√ßage
  - tests.lisp        : Fichier de tests
  - main.lisp         : Point d'entr√©e principal

√âtape 1.2 : D√©finition des constantes et opcodes
------------------------------------------------
‚ñ° D√©finir MAXMEM (taille maximale de la m√©moire)
‚ñ° D√©finir les registres :
  - R0, R1, R2 : registres g√©n√©raux
  - MEM : pointeur m√©moire
  - GT, LT, EQ : flags de comparaison
  - PL : pointeur de code (Program Location)
  - FP : Frame Pointer (base de la frame courante)
  - SP : Stack Pointer (sommet de la pile)
‚ñ° D√©finir le jeu d'instructions ASM :
  - Arithm√©tiques : ADD, SUB, MUL, DIV, MOD
  - Logiques : AND, OR, NOT
  - Comparaisons : CMP, JMP, JEQ, JNE, JGT, JLT
  - Pile : PUSH, POP
  - M√©moire : LOAD, STORE, MOVE
  - Appels : CALL, RET
  - Autres : NOP, HALT, LABEL

PHASE 2 : IMPL√âMENTATION DE LA MACHINE VIRTUELLE
================================================

√âtape 2.1 : Structure de la VM
------------------------------
‚ñ° Cr√©er une structure/classe VM avec :
  - memory : vecteur de taille MAXMEM
  - registres : hash-table ou structure
  - √©tat : running/halted/error
‚ñ° Impl√©menter les fonctions d'initialisation :
  - (make-vm) : cr√©e une nouvelle VM
  - (reset-vm vm) : r√©initialise la VM
  - (init-registers vm) : initialise les registres

√âtape 2.2 : Gestion de la m√©moire
---------------------------------
‚ñ° Impl√©menter la disposition m√©moire :
  - Zone variables basses (index 1 √† N)
  - Zone tas (allocation dynamique)
  - Zone pile (croissance descendante)
  - Zone code (en haut de la m√©moire)
‚ñ° Fonctions m√©moire :
  - (mem-read vm addr) : lecture √† une adresse
  - (mem-write vm addr value) : √©criture √† une adresse
  - (alloc-memory vm size) : allocation sur le tas
  - (check-memory-bounds vm addr) : v√©rification des limites

√âtape 2.3 : Gestion des registres
---------------------------------
‚ñ° Impl√©menter :
  - (get-register vm reg) : lire un registre
  - (set-register vm reg value) : √©crire un registre
  - (dump-registers vm) : afficher tous les registres

√âtape 2.4 : Gestion de la pile
------------------------------
‚ñ° Impl√©menter :
  - (push-stack vm value) : empiler une valeur
  - (pop-stack vm) : d√©piler une valeur
  - (peek-stack vm offset) : lire sans d√©piler
  - (get-stack-frame vm) : obtenir la frame courante

√âtape 2.5 : D√©codage et ex√©cution des instructions
--------------------------------------------------
‚ñ° Impl√©menter le fetch-decode-execute cycle :
  - (fetch-instruction vm) : r√©cup√©rer l'instruction au PL
  - (decode-instruction instr) : d√©coder l'instruction
  - (execute-instruction vm instr) : ex√©cuter l'instruction
‚ñ° Impl√©menter chaque instruction ASM :
  - Instructions arithm√©tiques
  - Instructions logiques
  - Instructions de comparaison
  - Instructions de saut
  - Instructions pile
  - Instructions m√©moire
  - Instructions d'appel de fonction

√âtape 2.6 : Boucle principale d'ex√©cution
-----------------------------------------
‚ñ° Impl√©menter (run-vm vm) :
  - Boucle fetch-decode-execute
  - Gestion des erreurs
  - Condition d'arr√™t (HALT ou erreur)
  - Compteur d'instructions pour d√©bogage

√âtape 2.7 : D√©l√©gation √† LISP
-----------------------------
‚ñ° Impl√©menter le m√©canisme de fallback :
  - D√©tecter les fonctions inconnues de la VM
  - Utiliser funcall/apply pour d√©l√©guer √† LISP
  - G√©rer les erreurs si LISP ne conna√Æt pas non plus

PHASE 3 : IMPL√âMENTATION DU CHARGEUR
====================================

√âtape 3.1 : Format du code assembleur
-------------------------------------
‚ñ° D√©finir le format de repr√©sentation du code ASM :
  - Format texte ou S-expressions ?
  - Exemple : ((PUSH 5) (PUSH 3) (ADD) (HALT))
  - Gestion des labels et des adresses

√âtape 3.2 : Parser ASM
---------------------
‚ñ° Impl√©menter (parse-asm code) :
  - Validation syntaxique
  - R√©solution des labels
  - Conversion en format interne

√âtape 3.3 : Chargement en m√©moire
---------------------------------
‚ñ° Impl√©menter (load-code vm asm-code) :
  - Placer le code en zone CODE
  - Initialiser PL au d√©but du code
  - G√©rer les symboles et r√©f√©rences

√âtape 3.4 : Liaison (Linking)
-----------------------------
‚ñ° Impl√©menter :
  - R√©solution des adresses symboliques
  - Table des symboles
  - Relocation si n√©cessaire

PHASE 4 : IMPL√âMENTATION DES OUTILS DE DEBUG
============================================

√âtape 4.1 : Visualisation
-------------------------
‚ñ° Impl√©menter :
  - (dump-memory vm start end) : afficher une zone m√©moire
  - (dump-stack vm) : afficher la pile
  - (dump-code vm) : d√©sassembler le code
  - (dump-vm-state vm) : √©tat complet de la VM

√âtape 4.2 : Tra√ßage
-------------------
‚ñ° Impl√©menter :
  - (trace-execution vm) : mode pas-√†-pas
  - (set-breakpoint vm addr) : points d'arr√™t
  - (log-instruction vm instr) : logger chaque instruction
  - Mode verbose pour d√©bogage

√âtape 4.3 : Statistiques
------------------------
‚ñ° Impl√©menter :
  - Compteur d'instructions ex√©cut√©es
  - Profiling (temps par instruction)
  - Utilisation m√©moire

PHASE 5 : IMPL√âMENTATION DU COMPILATEUR (BASE)
==============================================

√âtape 5.1 : Analyse du code source LISP
---------------------------------------
‚ñ° Impl√©menter :
  - (parse-lisp-expr expr) : parser une expression LISP
  - Reconnaissance des formes sp√©ciales
  - Construction d'un AST (Abstract Syntax Tree)

√âtape 5.2 : Environnement de compilation
----------------------------------------
‚ñ° Cr√©er une structure pour l'environnement :
  - Table des variables (locales et param√®tres)
  - Table des fonctions
  - Gestion des port√©es (scoping)
  - Compteur de labels uniques

√âtape 5.3 : Compilation des expressions simples
-----------------------------------------------
‚ñ° Impl√©menter la compilation de :
  - Constantes : (compile-const n) ‚Üí (PUSH n)
  - Variables : (compile-var x env) ‚Üí (LOAD x)
  - Op√©rations arithm√©tiques : +, -, *, /
  - Op√©rations de comparaison : <, >, =, <=, >=

√âtape 5.4 : Compilation des appels de fonction
----------------------------------------------
‚ñ° Impl√©menter :
  - Compilation des arguments (de droite √† gauche ou gauche √† droite)
  - Instruction CALL
  - Gestion de la frame d'appel
  - R√©cup√©ration du r√©sultat

PHASE 6 : COMPILATION DES STRUCTURES DE CONTR√îLE
================================================

√âtape 6.1 : Compilation de IF
-----------------------------
‚ñ° Impl√©menter (compile-if test then else env) :
  - Compiler la condition
  - G√©n√©rer un saut conditionnel (JEQ/JNE)
  - Compiler la branche THEN
  - Saut inconditionnel apr√®s THEN
  - Label pour la branche ELSE
  - Compiler la branche ELSE

√âtape 6.2 : Compilation de LET
------------------------------
‚ñ° Impl√©menter (compile-let bindings body env) :
  - Compiler les expressions d'initialisation
  - Empiler les valeurs
  - Cr√©er un nouvel environnement avec les bindings
  - Compiler le corps
  - Nettoyer la pile (d√©piler les variables locales)

√âtape 6.3 : Compilation de LOOP
-------------------------------
‚ñ° Impl√©menter (compile-loop body env) :
  - Label de d√©but de boucle
  - Compiler le corps
  - Saut inconditionnel vers le d√©but
  - G√©rer RETURN-FROM pour sortir

√âtape 6.4 : Compilation de SELECT/CASE
--------------------------------------
‚ñ° Impl√©menter (compile-case expr cases env) :
  - Compiler l'expression √† tester
  - Pour chaque cas : comparaison et saut conditionnel
  - Compiler le code de chaque branche
  - Sauts vers la fin apr√®s chaque cas

PHASE 7 : COMPILATION DES FONCTIONS
===================================

√âtape 7.1 : Compilation de DEFUN
--------------------------------
‚ñ° Impl√©menter (compile-defun name params body env) :
  - G√©n√©rer un label pour la fonction
  - Prologue : sauvegarder FP, initialiser nouvelle frame
  - R√©cup√©rer les param√®tres depuis la pile
  - Compiler le corps avec les param√®tres dans l'environnement
  - √âpilogue : restaurer FP, nettoyer pile, retour

√âtape 7.2 : Gestion de la r√©cursivit√©
-------------------------------------
‚ñ° Impl√©menter :
  - Sauvegarder le contexte avant appel r√©cursif
  - Restaurer le contexte apr√®s retour
  - Tester avec fibonacci

√âtape 7.3 : Compilation de LABELS (fonctions locales)
-----------------------------------------------------
‚ñ° Impl√©menter (compile-labels funcs body env) :
  - Cr√©er un environnement avec les fonctions locales
  - G√©n√©rer le code de chaque fonction locale
  - Compiler le corps avec l'environnement √©tendu

PHASE 8 : COMPILATION DES FERMETURES
====================================

√âtape 8.1 : Repr√©sentation des fermetures
-----------------------------------------
‚ñ° Concevoir la repr√©sentation m√©moire :
  - Pointeur vers le code de la fonction
  - Pointeur vers l'environnement captur√©
  - Structure sur le tas

√âtape 8.2 : Compilation de LAMBDA
---------------------------------
‚ñ° Impl√©menter (compile-lambda params body env) :
  - G√©n√©rer le code de la fonction
  - Capturer l'environnement (variables libres)
  - Allouer une fermeture sur le tas
  - Retourner un pointeur vers la fermeture

√âtape 8.3 : Appel de fermeture
------------------------------
‚ñ° Impl√©menter :
  - Distinguer appel direct vs appel de fermeture
  - Restaurer l'environnement captur√©
  - Ex√©cuter le code de la fermeture

PHASE 9 : OPTIMISATIONS DU COMPILATEUR
======================================

√âtape 9.1 : Transformations source-√†-source
-------------------------------------------
‚ñ° Impl√©menter des passes d'optimisation :
  - √âlimination du code mort
  - Propagation de constantes
  - Simplification d'expressions
  - D√©pliage de boucles simples (loop unrolling)

√âtape 9.2 : Optimisations du code ASM g√©n√©r√©
--------------------------------------------
‚ñ° Impl√©menter :
  - √âlimination des PUSH/POP cons√©cutifs
  - Utilisation des registres pour variables temporaires
  - Factorisation de code commun
  - Sauts optimis√©s (√©limination sauts vers sauts)

PHASE 10 : TESTS ET VALIDATION
==============================

√âtape 10.1 : Tests unitaires de la VM
-------------------------------------
‚ñ° Tester chaque instruction ASM individuellement
‚ñ° Tester la gestion de la pile
‚ñ° Tester la gestion de la m√©moire
‚ñ° Tester les registres

√âtape 10.2 : Tests du chargeur
------------------------------
‚ñ° Tester le chargement de code simple
‚ñ° Tester la r√©solution de labels
‚ñ° Tester la gestion d'erreurs

√âtape 10.3 : Tests du compilateur
---------------------------------
‚ñ° Tester expressions simples
‚ñ° Tester structures de contr√¥le
‚ñ° Tester appels de fonctions
‚ñ° Tester r√©cursivit√© (fibonacci)
‚ñ° Tester fermetures

√âtape 10.4 : Test de fibonacci(20)
----------------------------------
‚ñ° √âcrire fibonacci en LISP
‚ñ° Compiler fibonacci
‚ñ° Charger dans la VM
‚ñ° Compiler l'appel (fibo 20)
‚ñ° Charger l'appel dans la VM
‚ñ° Ex√©cuter
‚ñ° Mesurer le temps avec (time ...)
‚ñ° Comparer avec l'ex√©cution LISP native

√âtape 10.5 : Tests suppl√©mentaires
----------------------------------
‚ñ° Fonction factorielle
‚ñ° Fonction d'Ackermann
‚ñ° Manipulation de listes
‚ñ° Fonctions mutuellement r√©cursives

PHASE 11 : AUTO-COMPILATION (OBJECTIF AVANC√â)
=============================================

√âtape 11.1 : Compilation du chargeur
------------------------------------
‚ñ° Compiler le code du chargeur avec la VM
‚ñ° Charger le chargeur compil√© dans une VM
‚ñ° Tester le chargeur compil√©

√âtape 11.2 : Compilation de la VM
---------------------------------
‚ñ° Compiler le code de la VM avec elle-m√™me
‚ñ° Charger la VM compil√©e dans une VM
‚ñ° Lancer une VM dans la VM
‚ñ° Tester l'ex√©cution de code dans la VM imbriqu√©e

================================================================================
                        ORDRE DE PRIORIT√â
================================================================================

PRIORIT√â 1 (Critique - Faire en premier) :
- Phase 1 : Structure de base
- Phase 2 : Machine virtuelle compl√®te
- Phase 3 : Chargeur
- Phase 4 : Outils de debug (au fur et √† mesure)

PRIORIT√â 2 (Important) :
- Phase 5 : Compilateur de base
- Phase 6 : Structures de contr√¥le
- Phase 7 : Fonctions et r√©cursivit√©
- Phase 10.4 : Test fibonacci(20)

PRIORIT√â 3 (Fonctionnalit√©s avanc√©es) :
- Phase 8 : Fermetures
- Phase 9 : Optimisations
- Phase 10 : Tests exhaustifs

PRIORIT√â 4 (Bonus) :
- Phase 11 : Auto-compilation

================================================================================
                        NOTES IMPORTANTES
================================================================================

1. D√âVELOPPEMENT INCR√âMENTAL :
   - Impl√©menter, tester, d√©boguer chaque composant avant de passer au suivant
   - Commencer simple, complexifier progressivement
   - Toujours avoir une version fonctionnelle

2. PAS DE VARIABLES GLOBALES :
   - Passer la VM comme param√®tre
   - Passer l'environnement de compilation comme param√®tre
   - Utiliser des closures si n√©cessaire

3. OUTILS DE DEBUG :
   - Les impl√©menter d√®s le d√©but
   - Mode verbose pour tracer l'ex√©cution
   - Sauvegarder les √©tats interm√©diaires

4. GESTION D'ERREURS :
   - Valider les entr√©es
   - Messages d'erreur clairs
   - R√©cup√©ration gracieuse quand possible

5. DOCUMENTATION :
   - Commenter le code
   - Documenter le format ASM
   - Documenter les conventions d'appel
   - Documenter la disposition m√©moire

6. PERFORMANCE :
   - Ne pas optimiser pr√©matur√©ment
   - D'abord corrects, ensuite rapides
   - La VM sera plus lente que LISP natif (c'est normal)

================================================================================
                        PROCHAINES √âTAPES IMM√âDIATES
================================================================================

1. Cr√©er l'arborescence des fichiers du projet
2. D√©finir les constantes et opcodes dans asm-ops.lisp
3. Impl√©menter la structure de base de la VM dans vm.lisp
4. Impl√©menter les fonctions de gestion m√©moire
5. Commencer le jeu d'instructions avec les instructions simples
6. Cr√©er des tests unitaires au fur et √† mesure

================================================================================

Fin du plan d'action - Bonne chance pour l'impl√©mentation ! üöÄ
